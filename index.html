<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Nursing Calendar Scheduler ‚Äî Enhanced UI</title>

  <style>
    /* Admin Styles */
    .admin-toolbar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: var(--primary);
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 1000;
      box-shadow: var(--shadow-md);
    }

    .admin-toolbar-left {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }

    .admin-toolbar-right {
      display: flex;
      align-items: center;
    }

    .admin-toolbar .btn {
      font-size: 0.813rem;
      padding: 0.375rem 0.75rem;
    }

    body.admin-mode {
      padding-top: 3.5rem;
    }

    /* Modern UI Variables */
    :root {
      --primary: #3b82f6;
      --primary-hover: #2563eb;
      --secondary: #eff6ff;
      --success: #059669;
      --danger: #dc2626;
      --warning: #d97706;
      --info: #3b82f6;
      --bg: #eff6ff;
      --card: #ffffff;
      --text: #0f172a;
      --text-muted: #64748b;
      --border: #93c5fd;
      --sep-blue: #dbeafe;
      --sep-blue-border: #93c5fd;
      
      /* Spacing */
      --spacing-xs: 0.25rem;
      --spacing-sm: 0.5rem;
      --spacing-md: 1rem;
      --spacing-lg: 1.5rem;
      --spacing-xl: 2rem;
      
      /* Shadows */
      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
    }

    /* Copyright Protection Styles */
    body::before {
      content: "¬© 2025 Jennifer Ladesma - All Rights Reserved";
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      background: rgba(25, 43, 81, 0.95);
      color: white;
      text-align: center;
      padding: 2px 0;
      font-size: 10px;
      z-index: 9999;
      pointer-events: none;
    }

    /* Print Protection */
    @media print {
      body * { display: none !important; }
      body::after {
        content: "¬© 2025 Jennifer Ladesma - Printing Not Allowed";
        display: block !important;
        font-size: 24px;
        text-align: center;
        margin-top: 50px;
        color: #000;
      }
    }

    /* Visual Watermarking */
    body::after {
      content: "¬© 2025 Jennifer Ladesma";
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(25, 43, 81, 0.3);
      color: white;
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 11px;
      z-index: 9998;
      pointer-events: none;
      opacity: 0.7;
    }

    /* Reset & Base Styles */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Ubuntu, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.5;
      font-size: 14px;
    }

    /* Layout */
    .container {
      max-width: 1400px;
      margin: 2rem auto;
      padding: 0 var(--spacing-md);
    }

    /* Header Styles */
    .header {
      margin-bottom: var(--spacing-xl);
    }

    .header h1 {
      font-size: 1.875rem;
      font-weight: 800;
      color: var(--primary);
      margin-bottom: var(--spacing-xs);
    }

    .header .subtitle {
      color: var(--text-muted);
      font-size: 0.938rem;
    }

    /* Controls Section */
    .controls-section {
      background: var(--card);
      border-radius: 12px;
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-md);
      margin-bottom: var(--spacing-lg);
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-md);
    }

    /* Form Controls */
    .form-group {
      margin-bottom: var(--spacing-sm);
    }

    .form-group label {
      display: block;
      margin-bottom: var(--spacing-xs);
      font-weight: 500;
      color: var(--text);
    }

    .form-control {
      width: 100%;
      padding: 0.5rem 0.75rem;
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      font-size: 0.875rem;
      transition: border-color 0.15s ease;
    }

    .form-control:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }

    /* Improved textarea styling for manage lists */
    textarea.form-control {
      font-family: 'Courier New', monospace;
      font-size: 0.875rem;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
      overflow-wrap: break-word;
      overflow-x: hidden;
      overflow-y: auto;
      resize: vertical;
    }

    /* Drag and drop styling */
    .draggable-list {
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      min-height: 200px;
      max-height: 300px;
      overflow-y: auto;
      padding: 0.5rem;
      background: white;
    }

    .draggable-item {
      display: flex;
      align-items: center;
      padding: 0.5rem;
      margin-bottom: 0.25rem;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      border-radius: 0.375rem;
      cursor: move;
      user-select: none;
      transition: all 0.2s ease;
    }

    .draggable-item:hover {
      background: #e2e8f0;
      border-color: var(--primary);
    }

    .draggable-item.dragging {
      opacity: 0.5;
      transform: rotate(5deg);
    }

    .draggable-item.drag-over {
      border-top: 3px solid var(--primary);
    }

    .drag-handle {
      color: #6b7280;
      margin-right: 0.5rem;
      font-size: 1rem;
    }

    .item-text {
      flex: 1;
      font-family: 'Courier New', monospace;
      font-size: 0.875rem;
    }

    .item-remove {
      color: var(--danger);
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 0.25rem;
      margin-left: 0.5rem;
      transition: background-color 0.2s;
    }

    .item-remove:hover {
      background: #fee2e2;
    }

    .add-item-container {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      align-items: center;
    }

    .add-item-input {
      flex: 1;
      padding: 0.375rem 0.5rem;
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      font-size: 0.875rem;
    }

    .add-item-btn {
      padding: 0.375rem 0.75rem;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 0.875rem;
    }

    .add-item-btn:hover {
      background: var(--primary-hover);
    }

    /* Specific styling for month and year controls */
    #monthSelect {
      max-width: 180px;
      width: 180px;
      height: 42px;
    }
    
    #yearInput {
      max-width: 100px;
      width: 100px;
      height: 42px;
    }

    /* Adjust controls grid for better alignment */
    .controls-grid {
      display: grid;
      grid-template-columns: 180px 100px 1fr auto;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      align-items: end;
    }

    /* Ensure the full screen button stays aligned to the right */
    .controls-grid .form-group:nth-child(4) {
      justify-self: end;
    }

    /* Form group styling */
    .controls-grid .form-group {
      display: flex;
      flex-direction: column;
    }

    .controls-grid .form-group button {
      margin-top: auto;
    }

    /* Buttons */
    .btn-group {
      display: flex;
      gap: var(--spacing-sm);
      flex-wrap: wrap;
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      font-weight: 500;
      font-size: 0.875rem;
      cursor: pointer;
      transition: all 0.15s ease;
      border: 1px solid transparent;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-primary:hover {
      background: var(--primary-hover);
    }

    .btn-secondary {
      background: var(--secondary);
      color: var(--text);
      border-color: var(--border);
    }

    .btn-secondary:hover {
      background: #e2e8f0;
    }

    .btn-admin {
      background: var(--info);
      color: white;
    }

    .btn-admin:hover {
      background: #2563eb;
    }

    .btn-warning {
      background: var(--warning);
      color: white;
    }

    .btn-warning:hover {
      background: #b45309;
    }

    .btn-danger {
      background: var(--danger);
      color: white;
    }

    .btn-danger:hover {
      background: #b91c1c;
    }

    /* Search Bar */
    .search-container {
      margin-bottom: var(--spacing-lg);
      position: relative;
    }

    .search-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      max-width: 600px;
      margin: 0 auto;
    }

    .search-input {
      width: 100%;
      padding: 1rem 3.5rem 1rem 3rem;
      border: 2px solid var(--border);
      border-radius: 2rem;
      font-size: 1rem;
      background: var(--card);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow-lg), 0 0 20px var(--lavender-glow);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .search-input:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.2), var(--shadow-lg);
      transform: translateY(-2px);
      background: rgba(255, 255, 255, 0.95);
    }

    .search-input:not(:placeholder-shown) {
      border-color: var(--primary);
      background: var(--bg);
    }

    .search-icon {
      position: absolute;
      left: 0.75rem;
      top: 50%;
      transform: translateY(-50%);
      color: #6b7280;
      font-size: 1rem;
      pointer-events: none;
    }

    .search-clear {
      position: absolute;
      right: 0.75rem;
      top: 50%;
      transform: translateY(-50%);
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 50%;
      width: 1.5rem;
      height: 1.5rem;
      cursor: pointer;
      font-size: 0.75rem;
      display: none;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .search-clear:hover {
      background: #dc2626;
      transform: translateY(-50%) scale(1.1);
    }

    .search-clear.show {
      display: flex;
    }

    .search-results-info {
      text-align: center;
      margin-top: 0.5rem;
      font-size: 0.813rem;
      color: #6b7280;
      min-height: 1.2rem;
    }

    .search-results-info.active {
      color: var(--primary);
      font-weight: 500;
    }

    /* Enhanced Search Highlighting Styles */
    .search-highlight {
      background: linear-gradient(120deg, #fef08a 0%, #facc15 50%, #fef08a 100%);
      color: #374151;
      font-weight: bold;
      padding: 0.1rem 0.2rem;
      border-radius: 0.25rem;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      animation: highlightPulse 0.6s ease-in-out;
    }

    @keyframes highlightPulse {
      0% { background-color: rgba(254, 240, 138, 0.3); transform: scale(1); }
      50% { background-color: rgba(250, 204, 21, 0.8); transform: scale(1.05); }
      100% { background-color: rgba(254, 240, 138, 1); transform: scale(1); }
    }

    .search-stats-panel {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin-top: 0.75rem;
      padding: 0.75rem 1.5rem;
      background: linear-gradient(135deg, rgba(139, 92, 246, 0.1) 0%, rgba(219, 234, 254, 0.2) 100%);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 1rem;
      font-size: 0.813rem;
      font-weight: 500;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
      backdrop-filter: blur(10px);
      opacity: 0;
      transform: translateY(-10px);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .search-stats-panel.active {
      opacity: 1;
      transform: translateY(0);
    }

    .search-stat {
      display: flex;
      align-items: center;
      gap: 0.375rem;
      color: #4b5563;
    }

    .search-stat-icon {
      font-size: 1rem;
    }

    .search-stat-number {
      color: var(--primary);
      font-weight: bold;
      font-size: 1rem;
    }

    .search-stat-label {
      color: #6b7280;
      font-size: 0.75rem;
    }

    .search-no-results {
      text-align: center;
      padding: 2rem;
      color: #6b7280;
      font-style: italic;
      background: rgba(239, 68, 68, 0.05);
      border: 1px dashed #ef4444;
      border-radius: 0.5rem;
      margin: 1rem 0;
    }

    .table-row-hidden {
      display: none !important;
    }

    .table-row-highlighted {
      background: linear-gradient(135deg, rgba(254, 240, 138, 0.2) 0%, rgba(250, 204, 21, 0.1) 100%);
      border-left: 4px solid #facc15;
      animation: rowHighlight 0.4s ease-in-out;
    }

    @keyframes rowHighlight {
      0% { transform: translateX(-5px); opacity: 0.7; }
      100% { transform: translateX(0); opacity: 1; }
    }

    /* Enhanced Search Input States */
    .search-input.has-results {
      border-color: #10b981;
      box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.2), var(--shadow-lg);
    }

    .search-input.no-results {
      border-color: #ef4444;
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.2), var(--shadow-lg);
    }



    /* Table Styles */
    .table-container {
      background: var(--card);
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      overflow: hidden;
    }

    .table-info-panel {
      background: var(--secondary);
      border-bottom: 1px solid var(--border);
      padding: 0.75rem 1rem;
    }

    .info-stats {
      display: flex;
      gap: 1.5rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .info-stat {
      font-size: 0.875rem;
      color: var(--text);
    }

    .info-stat strong {
      color: var(--primary);
      font-weight: 600;
    }

    .table-scroll {
      overflow-x: auto;
      max-height: 70vh;
    }

    table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      table-layout: fixed;
    }

    th, td {
      padding: 0.75rem;
      border: 1px solid var(--border);
      background: white;
    }

    th {
      background: var(--primary);
      color: white;
      font-weight: 600;
      text-align: left;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    /* Sticky columns */
    .col-item { width: 80px; }
    .col-month { width: 140px; }
    .col-cohort { width: 190px; }

    .sticky-col {
      position: sticky;
      background: white;
      z-index: 25;
    }

    /* Sticky header columns should maintain turquoise background and stay fixed */
    th.sticky-col {
      background: var(--primary);
      color: white;
      position: sticky;
      top: 0;
      z-index: 30;
    }

    .sticky-col-1 { left: 0; }
    .sticky-col-2 { left: 80px; }

    /* Group separator */
    tr.group-sep td {
      background: var(--sep-blue) !important;
      border-top: 2px solid var(--sep-blue-border);
      border-bottom: 2px solid var(--sep-blue-border);
    }

    /* Dropdowns in table */
    .table-select {
      width: 100%;
      padding: 0.375rem 0.5rem;
      border: 1px solid var(--border);
      border-radius: 0.375rem;
      font-size: 0.875rem;
      background: white;
      transition: all 0.2s ease;
    }

    .table-select.incomplete {
      background-color: #fee2e2 !important;
      border-color: #dc2626 !important;
    }



    /* Fullscreen adjustments */
    body.fullscreen .table-scroll {
      max-height: calc(100vh - 180px);
    }

    body.fullscreen .container {
      max-width: none;
    }

    body.fullscreen .table-container {
      border-radius: 0;
    }

    /* Modern Modal Styles */
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 100;
      backdrop-filter: blur(4px);
    }

    .modal-content {
      background: white;
      border-radius: 12px;
      box-shadow: var(--shadow-lg);
      max-width: 600px;
      width: 90%;
      margin: 4vh auto;
      padding: var(--spacing-lg);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-md);
    }

    .modal-title {
      font-size: 1.25rem;
      font-weight: 600;
    }

    /* Toast Notifications */
    .toast-container {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 1000;
    }

    .toast {
      padding: 1rem;
      border-radius: 8px;
      background: white;
      box-shadow: var(--shadow-lg);
      margin-top: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      animation: slideIn 0.3s ease;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    /* Admin Features */
    .admin-only {
      display: none;
    }

    body.admin-mode .admin-only {
      display: flex;
    }

    /* Faculty Conflict Detection Styles */
    .conflict-list {
      max-height: 300px;
      overflow-y: auto;
    }

    .conflict-item {
      transition: all 0.2s ease;
    }

    .conflict-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    }

    .conflict-actions {
      border: 1px solid var(--border);
    }

    .suggestion-item {
      background: white;
      transition: all 0.2s ease;
    }

    .suggestion-item:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* Conflict indicator for instructor selects */
    .instructor-conflict {
      border: 2px solid #ef4444 !important;
      background: #fef2f2 !important;
    }

    .instructor-warning {
      border: 2px solid #f59e0b !important;
      background: #fffbeb !important;
    }

    /* Analytics Modal Styles */
    .analytics-modal-content {
      max-width: 95%;
      width: 1400px;
      height: 90vh;
      margin: 2vh auto;
    }

    /* Adjust analytics modal when admin mode is active */
    body.admin-mode .analytics-modal-content {
      height: 85vh;
      margin: 7vh auto 2vh auto;
    }

    .analytics-controls {
      background: var(--secondary);
      padding: var(--spacing-md);
      border-radius: 8px;
      margin-bottom: var(--spacing-md);
    }

    .analytics-row {
      display: flex;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-sm);
      align-items: end;
    }

    .analytics-row .form-group {
      flex: 1;
      min-width: 200px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      margin-top: 1.5rem;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      cursor: pointer;
      font-weight: 500;
    }

    .checkbox-label input[type="checkbox"] {
      margin-right: 8px;
      transform: scale(1.2);
    }

    .analytics-actions {
      display: flex;
      gap: var(--spacing-sm);
      justify-content: center;
      margin-top: var(--spacing-md);
    }

    .analytics-results {
      display: flex;
      gap: var(--spacing-md);
      height: calc(90vh - 250px);
    }

    .chart-container {
      flex: 2;
      background: white;
      border-radius: 8px;
      padding: var(--spacing-md);
      border: 1px solid var(--border);
    }

    .analytics-table-container {
      flex: 1;
      background: white;
      border-radius: 8px;
      padding: var(--spacing-md);
      border: 1px solid var(--border);
      overflow-y: auto;
      color: #000000;
    }

    .analytics-table-container h4 {
      color: #000000;
      font-weight: 600;
      margin-bottom: var(--spacing-sm);
    }

    .summary-stats {
      background: var(--secondary);
      padding: var(--spacing-sm);
      border-radius: 6px;
      margin-bottom: var(--spacing-md);
    }

    .summary-stats .stat-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 4px;
      font-size: 0.9rem;
      color: #000000;
    }

    .analytics-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85rem;
      color: #000000;
    }

    .analytics-table th,
    .analytics-table td {
      padding: 8px 4px;
      text-align: left;
      border-bottom: 1px solid var(--border);
      color: #000000;
    }

    .analytics-table th {
      background: var(--secondary);
      font-weight: 600;
      color: #000000;
      border-top: 1px solid var(--border);
      border-bottom: 2px solid var(--border);
    }

    .analytics-table td {
      font-family: 'Courier New', monospace;
      color: #000000;
    }

    #dataChart {
      max-height: 400px;
    }
  </style>
</head>
<body>
  <!-- Toast Container -->
  <div class="toast-container"></div>

  <!-- Admin Authentication Modal -->
  <div id="adminAuthModal" class="modal">
    <div class="modal-content" style="max-width: 400px;">
      <div class="modal-header">
        <h3 class="modal-title">Admin Authentication</h3>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="adminPassword">Enter Admin Password</label>
          <input type="password" id="adminPassword" class="form-control" placeholder="Enter password">
          <div class="hint" style="margin-top: 8px; color: var(--text-muted);">Contact administrator for access</div>
        </div>
        <div class="btn-group" style="justify-content: flex-end; margin-top: 1rem;">
          <button id="adminLoginBtn" class="btn btn-primary">Login</button>
          <button onclick="closeAdminAuth()" class="btn btn-secondary">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Admin Toolbar -->
  <div id="adminToolbar" class="admin-toolbar admin-only" style="display: none;">
    <div class="admin-toolbar-left">
      <button id="exportNormalizedCsvBtn" class="btn btn-admin">Export Normalized CSV</button>
      <button id="dataAnalyticsBtn" class="btn btn-admin">Data Analytics</button>
      <button id="conflictReportBtn" class="btn btn-admin">üö´ Conflict Report</button>
      <button id="conflictSettingsBtn" class="btn btn-admin">‚öôÔ∏è Conflict Rules</button>
    </div>
    <div class="admin-toolbar-right">
      <button id="adminLogoutBtn" class="btn btn-danger">Logout Admin</button>
    </div>
  </div>



  <div class="container">
    <header class="header">
      <h1>Nursing Calendar Scheduler</h1>
      <p class="subtitle">¬© 2025 Jennifer Ladesma - All Rights Reserved</p>
    </header>

    <section class="controls-section">
      <div class="controls-grid">
        <div class="form-group">
          <label for="monthSelect">Month</label>
          <select id="monthSelect" class="form-control" onchange="updateCalendar()">
            <option value="">Select Month</option>
            <option value="JAN">January</option>
            <option value="FEB">February</option>
            <option value="MAR">March</option>
            <option value="APR">April</option>
            <option value="MAY">May</option>
            <option value="JUN">June</option>
            <option value="JUL">July</option>
            <option value="AUG">August</option>
            <option value="SEP">September</option>
            <option value="OCT">October</option>
            <option value="NOV">November</option>
            <option value="DEC">December</option>
          </select>
          <input type="hidden" id="monthAbbrev" class="form-control" placeholder="e.g., NOV">
        </div>
        <div class="form-group">
          <label for="yearInput">Year</label>
          <input type="number" id="yearInput" class="form-control" value="2025" min="2000" max="2100" onchange="updateCalendar()">
        </div>
        <div class="form-group">
          <!-- Empty space to push button to the right -->
        </div>
        <div class="form-group" style="display: flex; align-items: flex-end; justify-self: end;">
          <button id="toggleFullBtn" class="btn btn-primary">Enter Full Screen</button>
        </div>
      </div>

      <div class="btn-group">
        <!-- Regular Buttons -->
        <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" style="display: none;">
        <input type="file" id="csvFileInput" accept=".csv" style="display: none;">
        <button id="importXlsxBtn" class="btn btn-primary">Import XLSX</button>
        <button id="importCsvBtn" class="btn btn-primary">Import CSV</button>
        <button id="exportXlsxBtn" class="btn btn-primary">Export XLSX</button>
        <button id="exportCsvBtn" class="btn btn-primary">Export CSV</button>
        <button id="exportPdfBtn" class="btn btn-primary">Export PDF</button>
        <button id="manageDropdowns" class="btn btn-primary">Manage Lists</button>
        <button id="manageColumns" class="btn btn-primary">Manage Columns</button>
        <button id="clearAllDataBtnMain" class="btn btn-warning">Clear All Data</button>

      </div>
    </section>

    <div class="search-container">
      <div class="search-wrapper">
        <span class="search-icon">üîç</span>
        <input type="text" id="search" class="search-input" placeholder="üîç Search anything: days, cohorts, instructors, sites, schedules... (Ctrl+F)">
        <button id="searchClear" class="search-clear" title="Clear search">√ó</button>
      </div>
      <div id="searchResults" class="search-results-info"></div>
      <div id="searchStatsPanel" class="search-stats-panel">
        <div class="search-stat">
          <span class="search-stat-icon">üëÅÔ∏è</span>
          <span class="search-stat-number" id="visibleRows">0</span>
          <span class="search-stat-label">visible</span>
        </div>
        <div class="search-stat">
          <span class="search-stat-icon">üéØ</span>
          <span class="search-stat-number" id="totalMatches">0</span>
          <span class="search-stat-label">matches</span>
        </div>
        <div class="search-stat">
          <span class="search-stat-icon">‚ú®</span>
          <span class="search-stat-number" id="highlightedCount">0</span>
          <span class="search-stat-label">highlighted</span>
        </div>
        <div class="search-stat">
          <span class="search-stat-icon">üìä</span>
          <span class="search-stat-number" id="totalRowsCount">0</span>
          <span class="search-stat-label">total rows</span>
        </div>
      </div>
    </div>

    <div class="table-container">
      <div class="table-info-panel">
        <div class="info-stats">
          <span class="info-stat">
            <strong>Total Rows:</strong> <span id="totalRows">0</span>
          </span>
          <span class="info-stat">
            <strong>Data Entries:</strong> <span id="dataEntries">0</span>
          </span>
          <span class="info-stat">
            <strong>Days:</strong> <span id="totalDays">0</span>
          </span>
          <span class="info-stat">
            <strong>Cohorts:</strong> <span id="totalCohorts">0</span>
          </span>
        </div>
      </div>
      <div id="tableWrap" class="table-scroll"></div>
    </div>
  </div>

  <!-- Manage Lists Modal -->
  <div id="listsModal" class="modal">
    <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
      <div class="modal-header">
        <h3 class="modal-title">Manage Lists</h3>
        <button id="closeLists" class="btn btn-secondary">&times;</button>
      </div>
      <div class="modal-body">
        <div style="background: #dbeafe; border: 1px solid #93c5fd; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem;">
          <strong>Note:</strong> The following options are automatically included and protected:
          <ul style="margin: 0.5rem 0 0 1rem; font-size: 0.875rem;">
            <li><strong>Empty option</strong> (first in list) - for blank selections</li>
            <li><strong>"Custom"</strong> - allows users to enter custom values</li>
            <li><strong>"Clear"</strong> - clears the selected field</li>
          </ul>
          <em style="font-size: 0.813rem;">These options cannot be removed and will be added automatically.</em>
        </div>
        <div class="form-group">
          <label>Sites (drag to reorder)</label>
          <div id="sitesContainer" class="draggable-list"></div>
          <div class="add-item-container">
            <input type="text" id="newSiteInput" class="add-item-input" placeholder="Add new site...">
            <button type="button" onclick="addNewItem('sites')" class="add-item-btn">Add</button>
          </div>
        </div>
        <div class="form-group">
          <label>Instructors (drag to reorder)</label>
          <div id="instructorsContainer" class="draggable-list"></div>
          <div class="add-item-container">
            <input type="text" id="newInstructorInput" class="add-item-input" placeholder="Add new instructor...">
            <button type="button" onclick="addNewItem('instructors')" class="add-item-btn">Add</button>
          </div>
        </div>
        <div class="form-group">
          <label>Schedule Templates (drag to reorder)</label>
          <div id="scheduleContainer" class="draggable-list"></div>
          <div class="add-item-container">
            <input type="text" id="newScheduleInput" class="add-item-input" placeholder="Add new schedule template...">
            <button type="button" onclick="addNewItem('schedule')" class="add-item-btn">Add</button>
          </div>
        </div>
        <div class="btn-group" style="justify-content: flex-end; margin-top: 1rem;">
          <button id="saveLists" class="btn btn-primary">Save Changes</button>
          <button class="btn btn-secondary" onclick="closeLists()">Cancel</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Manage Columns Modal -->
  <div id="columnsModal" class="modal">
    <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
      <div class="modal-header">
        <h3 class="modal-title">Manage Columns (Cohorts)</h3>
        <button id="closeColumns" class="btn btn-secondary">&times;</button>
      </div>
      <div class="modal-body">
        <div style="background: #dbeafe; border: 1px solid #93c5fd; border-radius: 0.5rem; padding: 0.75rem; margin-bottom: 1rem;">
          <strong>Note:</strong> Each cohort becomes a column in the calendar grid. You can add, remove, or reorder cohorts here.
          <br><em style="font-size: 0.813rem;">Changes will be applied immediately to the calendar.</em>
        </div>
        <div class="form-group">
          <label>Cohorts/Columns (drag to reorder)</label>
          <div id="cohortsContainer" class="draggable-list"></div>
          <div class="add-item-container">
            <input type="text" id="newCohortInput" class="add-item-input" placeholder="Add new cohort/column...">
            <button type="button" onclick="addNewCohort()" class="add-item-btn">Add</button>
          </div>
        </div>
        <div class="btn-group" style="justify-content: space-between; margin-top: 1rem;">
          <button id="resetColumns" class="btn btn-warning">Reset to Default</button>
          <div class="btn-group">
            <button id="saveColumns" class="btn btn-primary">Save Changes</button>
            <button class="btn btn-secondary" onclick="closeColumns()">Cancel</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Data Analytics Modal -->
  <div id="analyticsModal" class="modal">
    <div class="modal-content analytics-modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Data Analytics</h3>
        <button id="closeAnalytics" class="btn btn-secondary">&times;</button>
      </div>
      <div class="modal-body">
        <div class="analytics-controls">
          <div class="analytics-row">
            <div class="form-group">
              <label for="timePeriod">Time Period</label>
              <select id="timePeriod" class="form-control">
                <option value="week">1 Week</option>
                <option value="2weeks">2 Weeks</option>
                <option value="month">1 Month</option>
              </select>
            </div>
            <div class="form-group">
              <label for="facultySelect">Faculty Selection</label>
              <select id="facultySelect" class="form-control">
                <option value="all">All Faculty Members</option>
                <option value="individual">Individual Analysis</option>
              </select>
            </div>
            <div class="form-group">
              <label for="specificFaculty">Specific Faculty (if Individual)</label>
              <select id="specificFaculty" class="form-control" disabled>
                <option value="">Select Faculty Member</option>
              </select>
            </div>
          </div>
          
          <div class="analytics-row">
            <div class="form-group">
              <label for="chartType">Chart Type</label>
              <select id="chartType" class="form-control">
                <option value="bar">Bar Graph</option>
                <option value="line">Colored Bar Graph</option>
                <option value="pie">Pie Chart</option>
                <option value="histogram">Histogram</option>
              </select>
            </div>
            <div class="form-group">
              <label for="analysisType">Analysis Type</label>
              <select id="analysisType" class="form-control">
                <option value="hours">Total Hours</option>
                <option value="comparative">Comparative Analysis</option>
                <option value="trends">Time Trends</option>
              </select>
            </div>
            <div class="form-group checkbox-group">
              <label class="checkbox-label">
                <input type="checkbox" id="deductLunch">
                <span class="checkmark"></span>
                Deduct 0.5h lunch break per day
              </label>
            </div>
          </div>
          
          <div class="analytics-actions">
            <button id="generateAnalytics" class="btn btn-primary">Generate Analytics</button>
            <button id="exportAnalytics" class="btn btn-secondary">Export Chart</button>
            <button id="exportSummaryPdf" class="btn btn-secondary">Export Summary PDF</button>
            <button id="clearAnalytics" class="btn btn-warning">Clear</button>
          </div>
        </div>
        
        <div id="analyticsResults" class="analytics-results">
          <div id="analyticsChart" class="chart-container">
            <canvas id="dataChart"></canvas>
          </div>
          <div id="analyticsTable" class="analytics-table-container">
            <h4>Data Summary</h4>
            <div id="summaryStats" class="summary-stats"></div>
            <table id="detailsTable" class="analytics-table">
              <thead></thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Chart.js Library -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- XLSX Library -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <!-- ExcelJS Library for Professional Styling -->
  <script src="https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.min.js"></script>
  <!-- jsPDF Library for PDF Export -->
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf-autotable@3.5.25/dist/jspdf.plugin.autotable.min.js"></script>

  <script>
    // Copyright Protection & Anti-Copy Measures
    (function() {
      'use strict';
      
      // Disable right-click context menu
      document.addEventListener('contextmenu', function(e) {
        e.preventDefault();
        return false;
      });
      
      // Disable F12, Ctrl+Shift+I, Ctrl+U, Ctrl+S (Developer Tools and Save)
      document.addEventListener('keydown', function(e) {
        if (e.key === 'F12' || 
            (e.ctrlKey && e.shiftKey && e.key === 'I') ||
            (e.ctrlKey && e.key === 'u') ||
            (e.ctrlKey && e.key === 'U') ||
            (e.ctrlKey && e.key === 's') ||
            (e.ctrlKey && e.key === 'S')) {
          e.preventDefault();
          // Key combination blocked - silent prevention
          return false;
        }
      });
      
      // Disable text selection (but allow form interactions)
      document.addEventListener('selectstart', function(e) {
        // Allow selection in form inputs and content editable areas
        if (e.target.tagName === 'INPUT' || 
            e.target.tagName === 'TEXTAREA' || 
            e.target.tagName === 'SELECT' ||
            e.target.contentEditable === 'true') {
          return true;
        }
        e.preventDefault();
        return false;
      });
      
      // Clear console periodically and show copyright warnings
      setInterval(function() {
        console.clear();
        console.log('%c‚ö†Ô∏è COPYRIGHT PROTECTED ‚ö†Ô∏è', 'color: red; font-size: 20px; font-weight: bold;');
        console.log('%c¬© 2025 Jennifer Ladesma - All Rights Reserved', 'color: purple; font-size: 14px;');
        console.log('%cUnauthorized copying, modification, or distribution is strictly prohibited.', 'color: red; font-size: 12px;');
      }, 3000); // Every 3 seconds
      
    })();

    // State Management
    let state = {
      monthAbbrev: "",
      year: 2025,
      daysInMonth: 30,
      cohorts: ["VN B111 (D)","VN B113 (D)","VN B108 (D)","VN B112 (E)","VN B107 (E)","VN B109 (E)","VN B103","VN B110 (10)","NATP/HHA","RN-BSN","Make Up","Admin"],
      groupsPerDay: 4,
      data: {}
    };

    // DROPDOWN LISTS WITH SITE NAMES, INSTRUCTORS, AND SCHEDULE TEMPLATES
    const ORIGINAL_LISTS = {
      sites: [
        "",
        "Rosecrans A",
        "Kei Ai A", 
        "Pacific Palms A",
        "Gerontology",
        "Harbor B",
        "Beachside B",
        "TCCW B",
        "Maternity",
        "Endocrine",
        "den",
        "jen",
        "test",
        "Daniel",
        "Custom",
        "Clear"
      ],
      instructors: [
        "",
        "Lipkins",
        "Samad",
        "Garvida",
        "Espejo",
        "Assayag",
        "Sortigosa",
        "Tacandong",
        "Harmon",
        "Mendiola",
        "Thomas",
        "Dr. Valer",
        "Manansa",
        "den",
        "jen",
        "test",
        "Daniel",
        "Custom",
        "Clear"
      ],
      schedule: [
        "",
        "0700-1530",
        "0800-1600",
        "0900-1500",
        "1500-2330",
        "1600-2200",
        "8h",
        "3h;5h",
        "den",
        "jen",
        "test",
        "Daniel",
        "Custom",
        "Clear"
      ]
    };

    // Make lists editable - users can modify them through the Manage Lists modal
    const lists = {
      sites: [...ORIGINAL_LISTS.sites],
      instructors: [...ORIGINAL_LISTS.instructors],
      schedule: [...ORIGINAL_LISTS.schedule]
    };

    // Toast Notifications
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast toast-${type}`;
      toast.innerHTML = `
        <div class="toast-content">
          <span class="toast-message">${message}</span>
        </div>
      `;
      document.querySelector('.toast-container').appendChild(toast);
      
      setTimeout(() => {
        toast.style.opacity = '0';
        setTimeout(() => toast.remove(), 300);
      }, 3000);
    }

    // Simple auto-save - minimal background saving for session recovery
    function autoSave() {
      try {
        // Only save to sessionStorage for crash recovery - no permanent storage
        sessionStorage.setItem('nursing_session_backup', JSON.stringify(state));
      } catch(error) {
        console.error('Session backup failed:', error);
      }
    }

    // Utility Functions
    function monthToNum(abbr) {
      const map = {JAN:1,FEB:2,MAR:3,APR:4,MAY:5,JUN:6,JUL:7,AUG:8,SEP:9,OCT:10,NOV:11,DEC:12};
      return map[(abbr||'').toUpperCase()]||NaN;
    }

    function calcDaysInMonth(year, abbr) {
      const m = monthToNum(abbr);
      return isNaN(m) ? 30 : new Date(year, m, 0).getDate();
    }

    function weekday(year, abbr, day) {
      const m = monthToNum(abbr);
      if(isNaN(m)) {
        // If no valid month, calculate based on current date
        const currentDate = new Date();
        const startOfMonth = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
        const firstDayOfMonth = startOfMonth.getDay(); // 0 = Sunday, 6 = Saturday
        const dayIndex = (firstDayOfMonth + (day - 1)) % 7;
        const labels = ["SUN","MON","TUE","WED","THU","FRI","SAT"];
        return labels[dayIndex];
      }
      return new Date(year, m-1, day).toLocaleDateString(undefined,{weekday:'short'}).toUpperCase();
    }

    // Grid Functions
    function ensureGroup(day, co, idx) {
      if(!state.data[day]) state.data[day] = {};
      if(!state.data[day][co]) state.data[day][co] = [];
      if(!state.data[day][co][idx]) state.data[day][co][idx] = {site:'', instructor:'', schedule:''};
      return state.data[day][co][idx];
    }

    function createSelect(opts, val, onChange) {
      const sel = document.createElement('select');
      sel.className = 'table-select';
      opts.forEach(v => {
        const o = document.createElement('option');
        o.value = o.textContent = v;
        // Make Custom and Clear options bold
        if (v === 'Custom' || v === 'Clear') {
          o.style.fontWeight = 'bold';
        }
        sel.appendChild(o);
      });
      if(val && !opts.includes(val)) {
        const o = document.createElement('option');
        o.value = o.textContent = val;
        sel.appendChild(o);
      }
      sel.value = val || '';
      sel.onchange = () => {
        const selectedValue = sel.value;
        
        // Handle special "Clear" option
        if (selectedValue === 'Clear') {
          onChange('');
          sel.value = '';
          // Remove highlighting since field is now empty (not incomplete, just empty)
          sel.classList.remove('incomplete');
          autoSave();
          return;
        }
        
        // Handle special "Custom" option
        if (selectedValue === 'Custom') {
          const customValue = prompt('Enter custom value:');
          if (customValue !== null && customValue.trim() !== '') {
            const trimmedValue = customValue.trim();
            
            // Add custom value to dropdown if not already present
            if (!opts.includes(trimmedValue)) {
              const customOption = document.createElement('option');
              customOption.value = customOption.textContent = trimmedValue;
              // Insert before "Custom" and "Clear" options
              const customOptionIndex = Array.from(sel.options).findIndex(opt => opt.value === 'Custom');
              if (customOptionIndex > 0) {
                sel.insertBefore(customOption, sel.options[customOptionIndex]);
              } else {
                sel.appendChild(customOption);
              }
            }
            
            onChange(trimmedValue);
            sel.value = trimmedValue;
            // Auto-clear red highlighting since field now has a value
            sel.classList.remove('incomplete');
          } else {
            // User cancelled or entered empty value, revert to previous value
            sel.value = val || '';
          }
          autoSave();
          return;
        }
        
        // Handle normal selection
        onChange(selectedValue);
        
        // Auto-clear red highlighting if field was incomplete and now has a value
        if (selectedValue && selectedValue.trim() !== '') {
          sel.classList.remove('incomplete');
        }
        
        autoSave();
      };
      return sel;
    }

    // Render Calendar Grid
    function render() {
      const wrap = document.getElementById('tableWrap');
      wrap.innerHTML = '';
      
      const tbl = document.createElement('table');

      // Column groups for fixed widths
      const colg = document.createElement('colgroup');
      const c1 = document.createElement('col');
      c1.className = 'col-item';
      colg.appendChild(c1);
      
      const c2 = document.createElement('col');
      c2.className = 'col-month';
      colg.appendChild(c2);
      
      state.cohorts.forEach(() => {
        const cc = document.createElement('col');
        cc.className = 'col-cohort';
        colg.appendChild(cc);
      });
      tbl.appendChild(colg);

      // Header row
      const thead = document.createElement('thead');
      const trh = document.createElement('tr');
      
      const th1 = document.createElement('th');
      th1.textContent = "ITEM #";
      th1.className = 'sticky-col sticky-col-1';
      trh.appendChild(th1);
      
      const th2 = document.createElement('th');
      th2.textContent = state.monthAbbrev || "Month";
      th2.className = 'sticky-col sticky-col-2';
      trh.appendChild(th2);
      
      state.cohorts.forEach(co => {
        const th = document.createElement('th');
        th.textContent = co;
        trh.appendChild(th);
      });
      
      thead.appendChild(trh);
      tbl.appendChild(thead);

      // Table body
      const tbody = document.createElement('tbody');
      const filter = document.getElementById('search').value.toLowerCase();
      let item = 1;

      for(let day = 1; day <= state.daysInMonth; day++) {
        const dayText = `${day} - ${weekday(state.year, state.monthAbbrev, day)}`;
        
        for(let g = 0; g < state.groupsPerDay; g++) {
          // Sites row
          let tr = document.createElement('tr');
          let td = document.createElement('td');
          td.textContent = item++;
          td.className = 'sticky-col sticky-col-1';
          tr.appendChild(td);
          
          td = document.createElement('td');
          td.textContent = dayText;
          td.className = 'sticky-col sticky-col-2';
          tr.appendChild(td);
          
          state.cohorts.forEach(co => {
            const rec = ensureGroup(day, co, g);
            const ctd = document.createElement('td');
            ctd.appendChild(createSelect(lists.sites, rec.site, v => rec.site = v));
            tr.appendChild(ctd);
          });
          tbody.appendChild(tr);

          // Faculty row
          tr = document.createElement('tr');
          td = document.createElement('td');
          td.textContent = item++;
          td.className = 'sticky-col sticky-col-1';
          tr.appendChild(td);
          
          td = document.createElement('td');
          td.textContent = dayText;
          td.className = 'sticky-col sticky-col-2';
          tr.appendChild(td);
          
          state.cohorts.forEach(co => {
            const rec = ensureGroup(day, co, g);
            const ctd = document.createElement('td');
            ctd.appendChild(createSelect(lists.instructors, rec.instructor, v => rec.instructor = v));
            tr.appendChild(ctd);
          });
          tbody.appendChild(tr);

          // Schedule row
          tr = document.createElement('tr');
          td = document.createElement('td');
          td.textContent = item++;
          td.className = 'sticky-col sticky-col-1';
          tr.appendChild(td);
          
          td = document.createElement('td');
          td.textContent = dayText;
          td.className = 'sticky-col sticky-col-2';
          tr.appendChild(td);
          
          state.cohorts.forEach(co => {
            const rec = ensureGroup(day, co, g);
            const ctd = document.createElement('td');
            ctd.appendChild(createSelect(lists.schedule, rec.schedule, v => rec.schedule = v));
            tr.appendChild(ctd);
          });
          tbody.appendChild(tr);

          // Separator row
          tr = document.createElement('tr');
          tr.className = 'group-sep';
          td = document.createElement('td');
          td.textContent = item++;
          td.className = 'sticky-col sticky-col-1';
          tr.appendChild(td);
          
          td = document.createElement('td');
          td.textContent = dayText;
          td.className = 'sticky-col sticky-col-2';
          tr.appendChild(td);
          
          state.cohorts.forEach(() => {
            const ctd = document.createElement('td');
            ctd.textContent = '';
            tr.appendChild(ctd);
          });
          tbody.appendChild(tr);
        }
      }

      tbl.appendChild(tbody);
      wrap.appendChild(tbl);

      if (filter) {
        enhancedSearch(filter, tbody);
      }

      // Update statistics information panel
      updateStatistics();
    }

    // ENHANCED SEARCH SYSTEM
    function enhancedSearch(searchTerm, tbody) {
      if (!searchTerm || searchTerm.trim() === '') {
        clearSearchHighlights();
        updateSearchStats(0, 0, 0, tbody.rows.length);
        return;
      }

      const normalizedTerm = searchTerm.toLowerCase().trim();
      let visibleRows = 0;
      let totalMatches = 0;
      let highlightedElements = 0;
      const totalRows = tbody.rows.length;

      // Clear previous highlighting
      clearSearchHighlights();

      Array.from(tbody.rows).forEach(row => {
        let rowHasMatch = false;
        let rowMatchCount = 0;

        // Search in all text content of the row
        const cells = Array.from(row.cells);
        
        cells.forEach(cell => {
          // Search in text content of static cells (day, item numbers)
          if (cell.textContent) {
            const cellText = cell.textContent.toLowerCase();
            if (cellText.includes(normalizedTerm)) {
              highlightTextInElement(cell, normalizedTerm);
              rowHasMatch = true;
              rowMatchCount++;
              totalMatches++;
            }
          }

          // Search in dropdown/select elements
          const selects = cell.querySelectorAll('select');
          selects.forEach(select => {
            const selectValue = select.value.toLowerCase();
            if (selectValue && selectValue.includes(normalizedTerm)) {
              highlightSelectElement(select, normalizedTerm);
              rowHasMatch = true;
              rowMatchCount++;
              totalMatches++;
            }
          });
        });

        // Show/hide row and apply highlighting styles
        if (rowHasMatch) {
          row.style.display = '';
          row.classList.add('table-row-highlighted');
          visibleRows++;
        } else {
          row.style.display = 'none';
          row.classList.remove('table-row-highlighted');
        }
      });

      // Count highlighted elements
      highlightedElements = document.querySelectorAll('.search-highlight').length;

      // Update search input styling
      const searchInput = document.getElementById('search');
      searchInput.classList.remove('has-results', 'no-results');
      if (totalMatches > 0) {
        searchInput.classList.add('has-results');
      } else {
        searchInput.classList.add('no-results');
      }

      // Update statistics
      updateSearchStats(visibleRows, totalMatches, highlightedElements, totalRows);
    }

    function highlightTextInElement(element, searchTerm) {
      // Only highlight text in cells that don't contain form elements
      if (element.querySelector('select, input, button')) {
        return; // Skip cells with form elements to avoid breaking functionality
      }
      
      const text = element.textContent;
      const regex = new RegExp(`(${escapeRegExp(searchTerm)})`, 'gi');
      
      if (regex.test(text)) {
        const highlightedHTML = text.replace(regex, '<span class="search-highlight">$1</span>');
        element.innerHTML = highlightedHTML;
      }
    }

    function highlightSelectElement(select, searchTerm) {
      // Add highlighting class to the select element
      select.classList.add('search-highlight');
      
      // Create a temporary highlight indicator
      if (!select.parentElement.querySelector('.select-highlight-indicator')) {
        const indicator = document.createElement('span');
        indicator.className = 'select-highlight-indicator search-highlight';
        indicator.style.cssText = `
          position: absolute;
          right: -5px;
          top: -5px;
          width: 10px;
          height: 10px;
          border-radius: 50%;
          background: #facc15;
          z-index: 10;
          pointer-events: none;
        `;
        select.parentElement.style.position = 'relative';
        select.parentElement.appendChild(indicator);
      }
    }

    function clearSearchHighlights() {
      // Carefully remove highlight spans without breaking table structure
      document.querySelectorAll('.search-highlight').forEach(el => {
        if (el.tagName === 'SPAN' && el.classList.contains('search-highlight')) {
          // Replace highlighted spans with their text content
          const parent = el.parentNode;
          parent.replaceChild(document.createTextNode(el.textContent), el);
          parent.normalize(); // Merge adjacent text nodes
        } else {
          // Remove highlight class from select elements
          el.classList.remove('search-highlight');
        }
      });

      // Remove select highlight indicators
      document.querySelectorAll('.select-highlight-indicator').forEach(el => {
        el.remove();
      });

      // Remove row highlighting
      document.querySelectorAll('.table-row-highlighted').forEach(row => {
        row.classList.remove('table-row-highlighted');
      });

      // Reset search input styling
      const searchInput = document.getElementById('search');
      searchInput.classList.remove('has-results', 'no-results');
    }

    function updateSearchStats(visibleRows, totalMatches, highlightedCount, totalRows) {
      const statsPanel = document.getElementById('searchStatsPanel');
      const resultsInfo = document.getElementById('searchResults');
      
      // Update individual stat counters
      document.getElementById('visibleRows').textContent = visibleRows;
      document.getElementById('totalMatches').textContent = totalMatches;
      document.getElementById('highlightedCount').textContent = highlightedCount;
      document.getElementById('totalRowsCount').textContent = totalRows;

      // Update main results info
      if (totalMatches === 0 && document.getElementById('search').value.trim() !== '') {
        resultsInfo.textContent = 'No matches found';
        resultsInfo.classList.add('active');
        statsPanel.classList.remove('active');
        
        // Show no results message
        showNoResultsMessage();
      } else if (totalMatches > 0) {
        resultsInfo.textContent = `Found ${totalMatches} matches in ${visibleRows} rows`;
        resultsInfo.classList.add('active');
        statsPanel.classList.add('active');
        
        // Hide no results message
        hideNoResultsMessage();
      } else {
        resultsInfo.textContent = '';
        resultsInfo.classList.remove('active');
        statsPanel.classList.remove('active');
        hideNoResultsMessage();
      }

      // Update clear button visibility
      const clearButton = document.getElementById('searchClear');
      const searchTerm = document.getElementById('search').value.trim();
      clearButton.style.display = searchTerm ? 'flex' : 'none';
    }

    function showNoResultsMessage() {
      let noResultsDiv = document.getElementById('noResultsMessage');
      if (!noResultsDiv) {
        noResultsDiv = document.createElement('div');
        noResultsDiv.id = 'noResultsMessage';
        noResultsDiv.className = 'search-no-results';
        noResultsDiv.innerHTML = `
          <div style="font-size: 1.5rem; margin-bottom: 0.5rem;">üîç</div>
          <div style="font-weight: bold; margin-bottom: 0.25rem;">No matches found</div>
          <div style="font-size: 0.875rem;">Try different keywords or check your spelling</div>
        `;
        document.getElementById('tableWrap').appendChild(noResultsDiv);
      }
      noResultsDiv.style.display = 'block';
    }

    function hideNoResultsMessage() {
      const noResultsDiv = document.getElementById('noResultsMessage');
      if (noResultsDiv) {
        noResultsDiv.style.display = 'none';
      }
    }

    function escapeRegExp(string) {
      return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    // Update Statistics Information Panel
    function updateStatistics() {
      // Calculate total rows (each day has groupsPerDay * 4 rows: sites, faculty, schedule, separator)
      const totalRows = state.daysInMonth * state.groupsPerDay * 4;
      
      // Calculate data entries (non-empty values in the schedule data)
      let dataEntries = 0;
      for (let day = 1; day <= state.daysInMonth; day++) {
        for (let g = 0; g < state.groupsPerDay; g++) {
          state.cohorts.forEach(cohort => {
            const rec = ensureGroup(day, cohort, g);
            if (rec.site && rec.site.trim() !== '') dataEntries++;
            if (rec.instructor && rec.instructor.trim() !== '') dataEntries++;
            if (rec.schedule && rec.schedule.trim() !== '') dataEntries++;
          });
        }
      }

      const totalDays = state.daysInMonth;
      const totalCohorts = state.cohorts.length;

      // Update the display
      document.getElementById('totalRows').textContent = totalRows;
      document.getElementById('dataEntries').textContent = dataEntries;
      document.getElementById('totalDays').textContent = totalDays;
      document.getElementById('totalCohorts').textContent = totalCohorts;
    }

    // Check if all fields are completely empty
    function isDataCompletelyEmpty() {
      try {
        for(let day = 1; day <= state.daysInMonth; day++) {
          for(let g = 0; g < state.groupsPerDay; g++) {
            for(let cohortIndex = 0; cohortIndex < state.cohorts.length; cohortIndex++) {
              const cohort = state.cohorts[cohortIndex];
              const data = state.data[day]?.[cohort]?.[g] || {};
              
              // Check if any field has data
              if (data.site && data.site.trim() !== '' || 
                  data.instructor && data.instructor.trim() !== '' || 
                  data.schedule && data.schedule.trim() !== '') {
                return false; // Found at least one field with data
              }
            }
          }
        }
        return true; // All fields are empty
      } catch (error) {
        console.error('Error checking if data is empty:', error);
        return false; // Assume not empty if there's an error
      }
    }

    // Validation function for export operations
    function validateDataForExport() {
      try {
        const incompleteGroups = [];

        for(let day = 1; day <= state.daysInMonth; day++) {
          for(let g = 0; g < state.groupsPerDay; g++) {
            // Calculate item number for this group (matches table row numbering)
            const baseItemNumber = (day - 1) * state.groupsPerDay * 4 + g * 4 + 1;
            
            // Check each cohort for this group
            for(let cohortIndex = 0; cohortIndex < state.cohorts.length; cohortIndex++) {
              const cohort = state.cohorts[cohortIndex];
              const data = state.data[day]?.[cohort]?.[g] || {};
              
              // Check if group has any data at all
              const hasAnyData = data.site || data.instructor || data.schedule;
              
              if (hasAnyData) {
                // If group has some data, all fields must be filled
                const siteEmpty = !data.site || data.site.trim() === '';
                const instructorEmpty = !data.instructor || data.instructor.trim() === '';
                const scheduleEmpty = !data.schedule || data.schedule.trim() === '';
                
                if (siteEmpty || instructorEmpty || scheduleEmpty) {
                  const missingFields = [];
                  const itemNumbers = [];
                  
                  if (siteEmpty) {
                    missingFields.push('Site');
                    itemNumbers.push(`#${baseItemNumber} (Day ${day}, Site - ${cohort})`);
                  }
                  if (instructorEmpty) {
                    missingFields.push('Faculty');  
                    itemNumbers.push(`#${baseItemNumber + 1} (Day ${day}, Faculty - ${cohort})`);
                  }
                  if (scheduleEmpty) {
                    missingFields.push('Schedule');
                    itemNumbers.push(`#${baseItemNumber + 2} (Day ${day}, Schedule - ${cohort})`);
                  }
                  
                  incompleteGroups.push({
                    day: day,
                    cohort: cohort,
                    itemNumbers: itemNumbers,
                    missingFields: missingFields
                  });
                }
              }
            }
          }
        }

        return incompleteGroups;
      } catch (error) {
        console.error('Validation function error:', error);
        return [];
      }
    }

    // Highlight incomplete fields function
    function highlightIncompleteFields() {
      clearHighlighting(); // Clear any existing highlights first

      const tableRows = document.querySelectorAll('#tableWrap table tbody tr');
      
      for(let day = 1; day <= state.daysInMonth; day++) {
        for(let g = 0; g < state.groupsPerDay; g++) {
          for(let cohortIndex = 0; cohortIndex < state.cohorts.length; cohortIndex++) {
            const cohort = state.cohorts[cohortIndex];
            const data = state.data[day]?.[cohort]?.[g] || {};
            
            // Check if group has any data at all
            const hasAnyData = data.site || data.instructor || data.schedule;
            
            if (hasAnyData) {
              // If group has some data, highlight empty fields
              const siteEmpty = !data.site || data.site.trim() === '';
              const instructorEmpty = !data.instructor || data.instructor.trim() === '';
              const scheduleEmpty = !data.schedule || data.schedule.trim() === '';
              
              // Calculate which rows correspond to this group
              // Each day-group combination has 4 rows: site, faculty, schedule, separator
              const groupStartRow = (day - 1) * state.groupsPerDay * 4 + g * 4;
              
              // Column index: +2 because first two columns are item number and day
              const columnIndex = cohortIndex + 2;
              
              // Highlight site field if empty
              if (siteEmpty && tableRows[groupStartRow] && tableRows[groupStartRow].cells[columnIndex]) {
                const siteCell = tableRows[groupStartRow].cells[columnIndex];
                const select = siteCell.querySelector('.table-select');
                if (select) {
                  select.classList.add('incomplete');
                }
              }
              
              // Highlight instructor field if empty
              if (instructorEmpty && tableRows[groupStartRow + 1] && tableRows[groupStartRow + 1].cells[columnIndex]) {
                const instructorCell = tableRows[groupStartRow + 1].cells[columnIndex];
                const select = instructorCell.querySelector('.table-select');
                if (select) {
                  select.classList.add('incomplete');
                }
              }
              
              // Highlight schedule field if empty
              if (scheduleEmpty && tableRows[groupStartRow + 2] && tableRows[groupStartRow + 2].cells[columnIndex]) {
                const scheduleCell = tableRows[groupStartRow + 2].cells[columnIndex];
                const select = scheduleCell.querySelector('.table-select');
                if (select) {
                  select.classList.add('incomplete');
                }
              }
            }
          }
        }
      }
    }

    // Clear highlighting function
    function clearHighlighting() {
      document.querySelectorAll('.table-select.incomplete').forEach(select => {
        select.classList.remove('incomplete');
      });
    }

    // Import/Export Functions
    function exportCsv() {
      try {
        // Check if all fields are empty first
        if (isDataCompletelyEmpty()) {
          alert('Sorry this operation cannot be processed as all fields are empty. Please enter some data before exporting.');
          return;
        }
        
        // Validate data before export
        const incompleteGroups = validateDataForExport();
        
        if (incompleteGroups.length > 0) {
          // Highlight incomplete fields in the table
          highlightIncompleteFields();
          
          let errorMessage = 'Cannot export CSV: Please complete the following missing data:\n\n';
          
          incompleteGroups.forEach((group, index) => {
            errorMessage += `${index + 1}. Day ${group.day} - Cohort: "${group.cohort}"\n`;
            errorMessage += `   Missing: ${group.missingFields.join(', ')}\n`;
            errorMessage += `   Row References: ${group.itemNumbers.join(', ')}\n\n`;
          });
          
          errorMessage += 'Red highlighted fields in the table show exactly which fields need to be completed.';
          alert(errorMessage);
          return;
        }
        
        // Clear any existing highlighting if validation passes
        clearHighlighting();
      } catch (error) {
        console.error('CSV Export validation error:', error);
        alert('Error during validation. Please check the console for details.');
        return;
      }
      const rows = [];
      rows.push(["ITEM #", state.monthAbbrev||"Month", ...state.cohorts]);
      
      let item = 1;
      for(let day = 1; day <= state.daysInMonth; day++) {
        const dayText = `${day} - ${weekday(state.year,state.monthAbbrev,day)}`;
        for(let g = 0; g < state.groupsPerDay; g++) {
          rows.push([item++, dayText, ...state.cohorts.map(co => state.data[day]?.[co]?.[g]?.site || "")]);
          rows.push([item++, dayText, ...state.cohorts.map(co => state.data[day]?.[co]?.[g]?.instructor || "")]);
          rows.push([item++, dayText, ...state.cohorts.map(co => state.data[day]?.[co]?.[g]?.schedule || "")]);
          rows.push([item++, dayText, ...state.cohorts.map(_ => "")]);
        }
      }
      
      const csv = rows.map(r => r.map(v => `"${String(v).replace(/"/g,'""')}"`).join(",")).join("\n");
      const blob = new Blob([csv], {type: 'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `Calendar_${state.monthAbbrev||'CAL'}_${state.year}.csv`;
      a.click();
      URL.revokeObjectURL(url);
      showToast('CSV exported successfully', 'success');
    }

    // Helper function for PDF export
    function getFullMonthName(monthAbbr) {
      const monthMap = {
        'JAN': 'January', 'FEB': 'February', 'MAR': 'March',
        'APR': 'April', 'MAY': 'May', 'JUN': 'June',
        'JUL': 'July', 'AUG': 'August', 'SEP': 'September',
        'OCT': 'October', 'NOV': 'November', 'DEC': 'December'
      };
      return monthMap[monthAbbr.toUpperCase()] || monthAbbr;
    }

    function exportPdf() {
      try {
        // Check if all fields are empty first
        if (isDataCompletelyEmpty()) {
          alert('Sorry this operation cannot be processed as all fields are empty. Please enter some data before exporting.');
          return;
        }
        
        // Validate data before export
        const incompleteGroups = validateDataForExport();
        
        if (incompleteGroups.length > 0) {
          // Highlight incomplete fields in the table
          highlightIncompleteFields();
          
          let errorMessage = 'Cannot export PDF: Please complete the following missing data:\n\n';
          
          incompleteGroups.forEach((group, index) => {
            errorMessage += `${index + 1}. Day ${group.day} - Cohort: "${group.cohort}"\n`;
            errorMessage += `   Missing: ${group.missingFields.join(', ')}\n`;
            errorMessage += `   Row References: ${group.itemNumbers.join(', ')}\n\n`;
          });
          
          errorMessage += 'Red highlighted fields in the table show exactly which fields need to be completed.';
          alert(errorMessage);
          return;
        }
        
        // Clear any existing highlighting if validation passes
        clearHighlighting();
        
        showToast('Generating PDF...', 'info');
        
        // Initialize jsPDF with landscape orientation for better table display
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
          orientation: 'landscape',
          unit: 'mm',
          format: 'letter'
        });

        // Get page dimensions
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        
        // Enhanced professional header with gradient-like effect
        doc.setFillColor(139, 69, 200); // Main purple color
        doc.rect(0, 0, pageWidth, 35, 'F');
        
        // Add a subtle shadow effect
        doc.setFillColor(120, 60, 180); // Slightly darker purple for shadow
        doc.rect(0, 32, pageWidth, 3, 'F');

        // Title with enhanced styling
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(22);
        doc.setFont('helvetica', 'bold');
        doc.text('Nursing Calendar Scheduler', pageWidth / 2, 18, { align: 'center' });

        // Subtitle with actual month name
        doc.setFontSize(16);
        doc.setFont('helvetica', 'normal');
        const currentYear = state.year || new Date().getFullYear();
        const monthName = getFullMonthName(state.monthAbbrev || 'NOV');
        doc.text(`${monthName} ${currentYear}`, pageWidth / 2, 28, { align: 'center' });
        
        // Add decorative line under header
        doc.setDrawColor(200, 200, 200);
        doc.setLineWidth(0.5);
        doc.line(12, 38, pageWidth - 12, 38);

        // Reset text color for content
        doc.setTextColor(0, 0, 0);

        // First pass: Identify cohorts that actually have data (filter empty columns)
        const cohortsWithData = new Set();
        for (let day = 1; day <= state.daysInMonth; day++) {
          for (let g = 0; g < state.groupsPerDay; g++) {
            for (const cohort of state.cohorts) {
              const data = state.data[day]?.[cohort]?.[g] || {};
              if (data.site || data.instructor || data.schedule) {
                cohortsWithData.add(cohort);
              }
            }
          }
        }
        
        // Create filtered headers with FULL cohort names (no abbreviations to preserve meaning)
        const activeCohorts = state.cohorts.filter(cohort => cohortsWithData.has(cohort));
        
        const headers = ['Day', ...activeCohorts]; // Full cohort names preserved
        const tableData = [];

        // First, collect all days with data to know which is the very last group
        const daysWithData = [];
        for (let day = 1; day <= state.daysInMonth; day++) {
          let dayHasData = false;
          for (let g = 0; g < state.groupsPerDay; g++) {
            for (const cohort of state.cohorts) {
              const data = state.data[day]?.[cohort]?.[g] || {};
              if (data.site || data.instructor || data.schedule) {
                dayHasData = true;
                break;
              }
            }
            if (dayHasData) break;
          }
          if (dayHasData) {
            daysWithData.push(day);
          }
        }

        // Process each day with clear day format while keeping ALL data
        for (let dayIndex = 0; dayIndex < daysWithData.length; dayIndex++) {
          const day = daysWithData[dayIndex];
          const compactDay = `${day}${weekday(state.year, state.monthAbbrev, day).substring(0, 3)}`; // "1Wed" - clear 3-letter day
            // Process each group for this day - but compress multiple groups smartly
            const groupsWithData = [];
            
            for (let g = 0; g < state.groupsPerDay; g++) {
              let groupHasData = false;
              for (const cohort of state.cohorts) {
                const data = state.data[day]?.[cohort]?.[g] || {};
                if (data.site || data.instructor || data.schedule) {
                  groupHasData = true;
                  break;
                }
              }
              if (groupHasData) {
                groupsWithData.push(g);
              }
            }

            // For each group with data, create three ultra-compact rows
            groupsWithData.forEach((g, groupIndex) => {
              // Row 1: Site data (first row for each group)
              const siteRow = [groupIndex === 0 ? compactDay : '']; // Only show day on first group
              activeCohorts.forEach(cohort => {
                const siteValue = state.data[day]?.[cohort]?.[g]?.site || '';
                siteRow.push(siteValue);
              });
              tableData.push(siteRow);
              
              // Row 2: Faculty data (second row for each group) - NO separator  
              const facultyRow = [''];
              activeCohorts.forEach(cohort => {
                const instructorValue = state.data[day]?.[cohort]?.[g]?.instructor || '';
                facultyRow.push(instructorValue);
              });
              tableData.push(facultyRow);
              
              // Row 3: Schedule data (third row for each group) - NO separator
              const scheduleRow = [''];
              activeCohorts.forEach(cohort => {
                const scheduleValue = state.data[day]?.[cohort]?.[g]?.schedule || '';
                scheduleRow.push(scheduleValue);
              });
              tableData.push(scheduleRow);
              
              // Add separator AFTER the complete group (Site+Faculty+Schedule)
              // Add separator unless this is the very last group in the very last day
              const isLastDay = dayIndex === daysWithData.length - 1;
              const isLastGroupOfDay = groupIndex === groupsWithData.length - 1;
              const isVeryLastGroup = isLastDay && isLastGroupOfDay;
              
              if (!isVeryLastGroup) {
                const groupEndSeparator = Array(headers.length).fill('');
                groupEndSeparator._isGroupEndSeparator = true;
                tableData.push(groupEndSeparator);
              }
            });
        }

        // Create MAXIMUM compression to fit ALL columns on page
        const availableWidth = pageWidth - 8; // Minimal margins (4mm each side)
        const dayColumnWidth = 12; // Increased by 2 more pts for better day/date visibility
        const cohortColumnWidth = (availableWidth - dayColumnWidth) / activeCohorts.length;
        
        doc.autoTable({
          head: [headers],
          body: tableData,
          startY: 45,
          theme: 'grid',
          pageBreak: 'auto',
          styles: {
            fontSize: 8, // Increased by 2pts for better readability
            cellPadding: 1, // Minimal padding
            overflow: 'linebreak',
            valign: 'middle',
            halign: 'center',
            lineColor: [0, 0, 0],
            lineWidth: 0.2, // Thinner borders
            textColor: [0, 0, 0],
            fontFamily: 'helvetica'
          },
          headStyles: {
            fillColor: [70, 114, 196],
            textColor: [255, 255, 255],
            fontStyle: 'bold',
            fontSize: 8.5, // Increased by 2pts for better readability
            halign: 'left', // LEFT-ALIGNED headers to save space
            valign: 'middle',
            lineColor: [0, 0, 0],
            lineWidth: 0.3,
            cellPadding: 1, // Minimal header padding
            minCellHeight: 5 // Maximum compressed header height
          },
          bodyStyles: {
            lineColor: [0, 0, 0],
            lineWidth: 0.2,
            minCellHeight: 4, // Extremely compact rows
            cellPadding: 1
          },
          columnStyles: {
            0: { 
              cellWidth: dayColumnWidth,
              halign: 'center',
              fontStyle: 'bold',
              fillColor: [250, 252, 255],
              valign: 'middle',
              fontSize: 8
            }, // Maximum compressed Day column
            // All active cohort columns get minimal space but still readable
            ...Object.fromEntries(
              activeCohorts.map((cohort, index) => [
                index + 1, // Column index (0=Day, 1+=Active Cohorts only)
                { 
                  cellWidth: Math.max(cohortColumnWidth, 15), // Absolute minimum 15mm per column
                  fontSize: 8,
                  cellPadding: 1,
                  halign: 'left', // Left align for better space utilization
                  valign: 'top'
                }
              ])
            )
          },
          margin: { top: 35, right: 4, bottom: 15, left: 4 }, // Minimal margins
          // Enhanced styling for separators
          didParseCell: function(data) {
            // Style separator rows (between complete groups only)
            if (data.row.raw._isGroupEndSeparator) {
              data.cell.styles.minCellHeight = 2; // Thin separator row
              data.cell.styles.fillColor = [240, 240, 240]; // Light gray background
              data.cell.styles.lineWidth = 0.6; // Thicker border for separator
            }
            
            // Highlight day cells
            if (data.column.index === 0 && data.cell.text[0] && !data.row.raw._isGroupEndSeparator) {
              data.cell.styles.fillColor = [245, 250, 255];
              data.cell.styles.fontStyle = 'bold';
            }
          },
          // Enhanced alternating row pattern for better readability
          didParseCell: function(data) {
            // Highlight complete day groups with subtle background
            if (data.column.index === 0 && data.cell.text[0]) {
              // This is a day cell with content
              data.cell.styles.fillColor = [245, 250, 255]; // Slightly stronger blue
              data.cell.styles.fontStyle = 'bold';
            }
          },
          alternateRowStyles: {
            fillColor: [253, 254, 255] // Very subtle alternating
          },
          margin: { top: 35, right: 12, bottom: 20, left: 12 },
          didDrawPage: function(data) {
            // Enhanced footer with professional styling
            doc.setFillColor(245, 245, 245); // Light gray footer background
            doc.rect(0, pageHeight - 15, pageWidth, 15, 'F');
            
            doc.setFontSize(8);
            doc.setTextColor(60, 60, 60); // Dark gray text
            const generatedDate = new Date().toLocaleDateString('en-US', { 
              year: 'numeric', 
              month: 'long', 
              day: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              hour12: true
            });
            
            // Left footer: Generated date
            doc.text(`Generated: ${generatedDate}`, 12, pageHeight - 8);
            
            // Add a thin line above footer
            doc.setDrawColor(150, 150, 150);
            doc.setLineWidth(0.2);
            doc.line(0, pageHeight - 15, pageWidth, pageHeight - 15);
          },
          didDrawCell: function(data) {
            // We'll add page numbers after the table is complete
          }
        });

        // Add correct page numbers after table generation is complete
        const totalPages = doc.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
          doc.setPage(i);
          doc.setFontSize(8);
          doc.setTextColor(60, 60, 60);
          doc.text(`Page ${i} of ${totalPages}`, pageWidth - 12, pageHeight - 8, { align: 'right' });
        }

        // Get current month and year for filename  
        const currentMonthAbbr = state.monthAbbrev || new Date().toLocaleDateString('en-US', { month: 'short' }).toUpperCase();
        const filename = `Nursing_Calendar_Schedule_${currentMonthAbbr}_${currentYear}.pdf`;

        // Save the PDF
        doc.save(filename);
        
        showToast('PDF exported successfully!', 'success');

      } catch (error) {
        console.error('PDF Export error:', error);
        alert('Error during PDF export. Please check the console for details.');
      }
    }

    function exportXlsx() {
      try {
        // Check if all fields are empty first
        if (isDataCompletelyEmpty()) {
          alert('Sorry this operation cannot be processed as all fields are empty. Please enter some data before exporting.');
          return;
        }
        
        // Validate data before export
        const incompleteGroups = validateDataForExport();
        
        if (incompleteGroups.length > 0) {
          // Highlight incomplete fields in the table
          highlightIncompleteFields();
          
          let errorMessage = 'Cannot export XLSX: Please complete the following missing data:\n\n';
          
          incompleteGroups.forEach((group, index) => {
            errorMessage += `${index + 1}. Day ${group.day} - Cohort: "${group.cohort}"\n`;
            errorMessage += `   Missing: ${group.missingFields.join(', ')}\n`;
            errorMessage += `   Row References: ${group.itemNumbers.join(', ')}\n\n`;
          });
          
          errorMessage += 'Red highlighted fields in the table show exactly which fields need to be completed.';
          alert(errorMessage);
          return;
        }
        
        // Clear any existing highlighting if validation passes
        clearHighlighting();
      } catch (error) {
        console.error('Validation error:', error);
        alert('Error during validation. Please check the console for details.');
        return;
      }
      
      // Create workbook first
      const wb = XLSX.utils.book_new();
      
      // Create worksheet data array
      const wsData = [];
      
      // Header row
      const headerRow = [state.monthAbbrev || "Month", ...state.cohorts];
      wsData.push(headerRow);
      
      // Add data rows
      for(let day = 1; day <= state.daysInMonth; day++) {
        const dayText = `${day} - ${weekday(state.year, state.monthAbbrev, day)}`;
        
        for(let g = 0; g < state.groupsPerDay; g++) {
          // Check if group has any data
          let hasData = false;
          for(const cohort of state.cohorts) {
            const data = state.data[day]?.[cohort]?.[g] || {};
            if(data.site || data.instructor || data.schedule) {
              hasData = true;
              break;
            }
          }
          
          // Skip empty groups entirely
          if(!hasData) {
            continue;
          }
          
          // Sites row
          const sitesRow = [dayText];
          state.cohorts.forEach(cohort => {
            const siteValue = state.data[day]?.[cohort]?.[g]?.site || "";
            sitesRow.push(siteValue);
          });
          wsData.push(sitesRow);
          
          // Faculty row
          const facultyRow = [dayText];
          state.cohorts.forEach(cohort => {
            const instructorValue = state.data[day]?.[cohort]?.[g]?.instructor || "";
            facultyRow.push(instructorValue);
          });
          wsData.push(facultyRow);
          
          // Schedule row
          const scheduleRow = [dayText];
          state.cohorts.forEach(cohort => {
            const scheduleValue = state.data[day]?.[cohort]?.[g]?.schedule || "";
            scheduleRow.push(scheduleValue);
          });
          wsData.push(scheduleRow);
          
          // Add empty row for spacing
          wsData.push(Array(state.cohorts.length + 1).fill(""));
        }
      }
      
      // Create worksheet from data
      const ws = XLSX.utils.aoa_to_sheet(wsData);
      
      // Apply styling manually to each cell
      const range = XLSX.utils.decode_range(ws['!ref']);
      
      // Style header row (row 0)
      for(let c = range.s.c; c <= range.e.c; c++) {
        const cellAddress = XLSX.utils.encode_cell({r: 0, c: c});
        if(ws[cellAddress]) {
          ws[cellAddress].s = {
            fill: { fgColor: { rgb: "4472C4" } },
            font: { color: { rgb: "FFFFFF" }, bold: true, sz: 14 },
            alignment: { horizontal: "center", vertical: "center" },
            border: {
              top: { style: "medium", color: { rgb: "000000" } },
              bottom: { style: "medium", color: { rgb: "000000" } },
              left: { style: "medium", color: { rgb: "000000" } },
              right: { style: "medium", color: { rgb: "000000" } }
            }
          };
        }
      }
      
      // Style data rows
      for(let r = 1; r <= range.e.r; r++) {
        for(let c = range.s.c; c <= range.e.c; c++) {
          const cellAddress = XLSX.utils.encode_cell({r: r, c: c});
          if(ws[cellAddress] && ws[cellAddress].v !== "") {
            if(c === 0) {
              // Day header column styling
              ws[cellAddress].s = {
                fill: { fgColor: { rgb: "E8F4FD" } },
                font: { bold: true, sz: 11 },
                alignment: { horizontal: "center", vertical: "center" },
                border: {
                  top: { style: "thin", color: { rgb: "B0B0B0" } },
                  bottom: { style: "thin", color: { rgb: "B0B0B0" } },
                  left: { style: "thin", color: { rgb: "B0B0B0" } },
                  right: { style: "thin", color: { rgb: "B0B0B0" } }
                }
              };
            } else {
              // Data cells styling
              ws[cellAddress].s = {
                font: { sz: 11 },
                alignment: { horizontal: "center", vertical: "center" },
                border: {
                  top: { style: "thin", color: { rgb: "D0D0D0" } },
                  bottom: { style: "thin", color: { rgb: "D0D0D0" } },
                  left: { style: "thin", color: { rgb: "D0D0D0" } },
                  right: { style: "thin", color: { rgb: "D0D0D0" } }
                }
              };
            }
          }
        }
      }
      
      // Set column widths
      const colWidths = [{ wch: 18 }]; // Month/Date column
      state.cohorts.forEach(() => {
        colWidths.push({ wch: 15 }); // Cohort columns
      });
      ws['!cols'] = colWidths;
      
      // Set row heights
      const rowHeights = [];
      for (let i = 0; i <= range.e.r; i++) {
        if (i === 0) {
          rowHeights.push({ hpt: 25 }); // Header row taller
        } else {
          // Check if it's an empty row
          let isEmpty = true;
          for(let c = range.s.c; c <= range.e.c; c++) {
            const cellAddress = XLSX.utils.encode_cell({r: i, c: c});
            if(ws[cellAddress] && ws[cellAddress].v !== "") {
              isEmpty = false;
              break;
            }
          }
          if(isEmpty) {
            rowHeights.push({ hpt: 8 }); // Empty rows minimal height
          } else {
            rowHeights.push({ hpt: 20 }); // Regular rows
          }
        }
      }
      ws['!rows'] = rowHeights;
      
      // Add worksheet to workbook
      XLSX.utils.book_append_sheet(wb, ws, `${state.monthAbbrev || 'CAL'} ${state.year}`);
      
      // Export with styling
      XLSX.writeFile(wb, `Calendar_${state.monthAbbrev || 'CAL'}_${state.year}.xlsx`);
      showToast('Professional XLSX exported with blue headers and borders', 'success');
    }

    // Export Normalized CSV (matching the raw_export_preview format)
    function exportNormalizedCsv() {
      try {
        // Check if all fields are empty first
        if (isDataCompletelyEmpty()) {
          alert('Sorry this operation cannot be processed as all fields are empty. Please enter some data before exporting.');
          return;
        }
        
        // Validate data before export
        const incompleteGroups = validateDataForExport();
        
        if (incompleteGroups.length > 0) {
          // Highlight incomplete fields in the table
          highlightIncompleteFields();
          
          let errorMessage = 'Cannot export Normalized CSV: Please complete the following missing data:\n\n';
          
          incompleteGroups.forEach((group, index) => {
            errorMessage += `${index + 1}. Day ${group.day} - Cohort: "${group.cohort}"\n`;
            errorMessage += `   Missing: ${group.missingFields.join(', ')}\n`;
            errorMessage += `   Row References: ${group.itemNumbers.join(', ')}\n\n`;
          });
          
          errorMessage += 'Red highlighted fields in the table show exactly which fields need to be completed.';
          alert(errorMessage);
          return;
        }
        
        // Clear any existing highlighting if validation passes
        clearHighlighting();
      } catch (error) {
        console.error('Normalized CSV Export validation error:', error);
        alert('Error during validation. Please check the console for details.');
        return;
      }
      
      const rows = [];
      
      // Header row matching the CSV format
      rows.push(['#', 'Date', 'Site', 'Cohort', 'Faculty', 'Schedule', 'Hours', 'Comments', 'Validation Notes']);
      
      let sequenceNumber = 1;
      
      for(let day = 1; day <= state.daysInMonth; day++) {
        const dayText = `${day} - ${weekday(state.year, state.monthAbbrev, day)}`;
        
        for(let g = 0; g < state.groupsPerDay; g++) {
          for(const cohort of state.cohorts) {
            const data = state.data[day]?.[cohort]?.[g] || {};
            
            // Only export rows that have at least site, instructor, or schedule data
            if(data.site || data.instructor || data.schedule) {
              // Calculate hours from schedule if available
              let hours = '';
              let validationNotes = '';
              
              if(data.schedule) {
                // Try to extract hours from common schedule patterns
                if(data.schedule.includes('h')) {
                  // Direct hour notation like "8h", "5.5h"
                  const hourMatch = data.schedule.match(/(\d+(?:\.\d+)?)\s*h/);
                  if(hourMatch) {
                    hours = hourMatch[1];
                  }
                } else if(data.schedule.includes('-')) {
                  // Time range like "0700-1530"
                  const timeMatch = data.schedule.match(/(\d{4})-(\d{4})/);
                  if(timeMatch) {
                    const startTime = parseInt(timeMatch[1]);
                    const endTime = parseInt(timeMatch[2]);
                    
                    // Convert to hours (simple calculation)
                    const startHour = Math.floor(startTime / 100) + (startTime % 100) / 60;
                    const endHour = Math.floor(endTime / 100) + (endTime % 100) / 60;
                    let duration = endHour - startHour;
                    
                    // Handle overnight shifts
                    if(duration < 0) {
                      duration += 24;
                    }
                    
                    hours = duration.toString();
                  }
                }
              }
              
              // Validation checks
              if((data.site && !data.instructor) || (!data.site && data.instructor)) {
                validationNotes = 'Incomplete. Wrong Data Entry. Please fix the source table and click on Export Raw CSV again.';
              } else if(data.schedule && (!data.site || !data.instructor)) {
                validationNotes = 'Incomplete. Wrong Data Entry. Please fix the source table and click on Export Raw CSV again.';
              }
              
              rows.push([
                sequenceNumber.toString(),
                dayText,
                data.site || '',
                cohort,
                data.instructor || '',
                data.schedule || '',
                hours,
                '', // Comments (empty for now, can be extended)
                validationNotes
              ]);
            }
          }
        }
        
        // Increment sequence number for each day (matching the pattern in your CSV)
        sequenceNumber += 4; // This matches the pattern in your sample CSV
      }
      
      // Convert to CSV format
      const csv = rows.map(row => 
        row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')
      ).join('\n');
      
      // Download the file
      const blob = new Blob([csv], {type: 'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `Normalized_Export_${state.monthAbbrev||'CAL'}_${state.year}.csv`;
      a.click();
      URL.revokeObjectURL(url);
      
      showToast('Normalized CSV exported successfully', 'success');
    }

    // Drag and Drop List Management
    let draggedElement = null;

    function createDraggableItem(text, listType) {
      const item = document.createElement('div');
      item.className = 'draggable-item';
      item.draggable = true;
      item.innerHTML = `
        <span class="drag-handle">‚ãÆ‚ãÆ</span>
        <span class="item-text">${text}</span>
        <span class="item-remove" onclick="removeItem(this, '${listType}')">&times;</span>
      `;
      
      // Add drag event listeners
      item.addEventListener('dragstart', handleDragStart);
      item.addEventListener('dragover', handleDragOver);
      item.addEventListener('drop', handleDrop);
      item.addEventListener('dragend', handleDragEnd);
      
      return item;
    }

    function handleDragStart(e) {
      draggedElement = this;
      this.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    }

    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      
      const afterElement = getDragAfterElement(this.parentNode, e.clientY);
      if (afterElement == null) {
        this.parentNode.appendChild(draggedElement);
      } else {
        this.parentNode.insertBefore(draggedElement, afterElement);
      }
    }

    function handleDrop(e) {
      e.preventDefault();
      this.classList.remove('drag-over');
    }

    function handleDragEnd(e) {
      this.classList.remove('dragging');
      draggedElement = null;
      
      // Remove drag-over class from all items
      document.querySelectorAll('.draggable-item').forEach(item => {
        item.classList.remove('drag-over');
      });
    }

    function getDragAfterElement(container, y) {
      const draggableElements = [...container.querySelectorAll('.draggable-item:not(.dragging)')];
      
      return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        
        if (offset < 0 && offset > closest.offset) {
          return { offset: offset, element: child };
        } else {
          return closest;
        }
      }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    function removeItem(button, listType) {
      const itemName = button.previousElementSibling.textContent;
      const confirmMessage = listType === 'cohorts' 
        ? `Remove cohort "${itemName}"? This will remove all data associated with this cohort.`
        : `Remove "${itemName}" from ${listType}?`;
        
      if (confirm(confirmMessage)) {
        button.parentElement.remove();
      }
    }

    function addNewItem(listType) {
      const inputIds = {
        'sites': 'newSiteInput',
        'instructors': 'newInstructorInput',
        'schedule': 'newScheduleInput'
      };
      
      const containerIds = {
        'sites': 'sitesContainer',
        'instructors': 'instructorsContainer',
        'schedule': 'scheduleContainer'
      };
      
      const input = document.getElementById(inputIds[listType]);
      const container = document.getElementById(containerIds[listType]);
      const text = input.value.trim();
      
      if (text && text !== 'Custom' && text !== 'Clear') {
        const item = createDraggableItem(text, listType);
        container.appendChild(item);
        input.value = '';
      } else if (text === 'Custom' || text === 'Clear') {
        showToast('Cannot add protected items (Custom/Clear)', 'error');
      } else {
        showToast('Please enter a valid item name', 'error');
      }
    }

    // Cohort Management Functions
    function addNewCohort() {
      const input = document.getElementById('newCohortInput');
      const container = document.getElementById('cohortsContainer');
      const text = input.value.trim();
      
      if (text) {
        const item = createDraggableItem(text, 'cohorts');
        container.appendChild(item);
        input.value = '';
      } else {
        showToast('Please enter a valid cohort name', 'error');
      }
    }

    function populateDraggableCohorts() {
      const cohortsContainer = document.getElementById('cohortsContainer');
      cohortsContainer.innerHTML = '';
      
      state.cohorts.forEach(cohort => {
        cohortsContainer.appendChild(createDraggableItem(cohort, 'cohorts'));
      });
    }

    function populateDraggableLists() {
      // Get editable items (exclude protected options)
      const editableSites = lists.sites.filter(item => item !== '' && item !== 'Custom' && item !== 'Clear');
      const editableInstructors = lists.instructors.filter(item => item !== '' && item !== 'Custom' && item !== 'Clear');
      const editableSchedule = lists.schedule.filter(item => item !== '' && item !== 'Custom' && item !== 'Clear');
      
      // Populate sites
      const sitesContainer = document.getElementById('sitesContainer');
      sitesContainer.innerHTML = '';
      editableSites.forEach(site => {
        sitesContainer.appendChild(createDraggableItem(site, 'sites'));
      });
      
      // Populate instructors
      const instructorsContainer = document.getElementById('instructorsContainer');
      instructorsContainer.innerHTML = '';
      editableInstructors.forEach(instructor => {
        instructorsContainer.appendChild(createDraggableItem(instructor, 'instructors'));
      });
      
      // Populate schedule templates
      const scheduleContainer = document.getElementById('scheduleContainer');
      scheduleContainer.innerHTML = '';
      editableSchedule.forEach(schedule => {
        scheduleContainer.appendChild(createDraggableItem(schedule, 'schedule'));
      });
    }

    // Enhanced keyboard support for add inputs
    function setupKeyboardSupport() {
      ['newSiteInput', 'newInstructorInput', 'newScheduleInput'].forEach(inputId => {
        const input = document.getElementById(inputId);
        if (input) {
          input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              const listType = inputId.replace('new', '').replace('Input', '').toLowerCase();
              addNewItem(listType === 'instructor' ? 'instructors' : listType);
            }
          });
        }
      });
    }

    // Modal Functions
    function openLists() {
      populateDraggableLists();
      document.getElementById('listsModal').style.display = 'block';
      
      // Setup keyboard support after modal is shown
      setTimeout(setupKeyboardSupport, 100);
    }

    function saveLists() {
      // Extract items from draggable containers
      const sitesContainer = document.getElementById('sitesContainer');
      const instructorsContainer = document.getElementById('instructorsContainer');
      const scheduleContainer = document.getElementById('scheduleContainer');
      
      // Get ordered items from containers
      const siteItems = Array.from(sitesContainer.querySelectorAll('.item-text')).map(el => el.textContent.trim());
      const instructorItems = Array.from(instructorsContainer.querySelectorAll('.item-text')).map(el => el.textContent.trim());
      const scheduleItems = Array.from(scheduleContainer.querySelectorAll('.item-text')).map(el => el.textContent.trim());
      
      // Update the lists with new values (maintain order from drag-and-drop)
      lists.sites = siteItems.filter(item => item !== '' && item !== 'Custom' && item !== 'Clear');
      lists.instructors = instructorItems.filter(item => item !== '' && item !== 'Custom' && item !== 'Clear');
      lists.schedule = scheduleItems.filter(item => item !== '' && item !== 'Custom' && item !== 'Clear');
      
      // Ensure empty string is always first option
      lists.sites.unshift('');
      lists.instructors.unshift('');
      lists.schedule.unshift('');
      
      // PROTECTED: Always ensure Custom and Clear are at the end - these cannot be removed
      lists.sites.push('Custom', 'Clear');
      lists.instructors.push('Custom', 'Clear');
      lists.schedule.push('Custom', 'Clear');
      
      // Close modal and re-render
      document.getElementById('listsModal').style.display = 'none';
      render();
      
      // Auto-save the updated lists
      if (typeof autoSave === 'function') {
        autoSave();
      }
      
      showToast('Lists updated successfully with your custom order!', 'success');
    }

    function closeLists() {
      document.getElementById('listsModal').style.display = 'none';
    }

    // Column Management Functions
    function openColumns() {
      populateDraggableCohorts();
      document.getElementById('columnsModal').style.display = 'block';
      
      // Setup keyboard support for cohort input
      setTimeout(() => {
        const input = document.getElementById('newCohortInput');
        if (input) {
          input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
              addNewCohort();
            }
          });
        }
      }, 100);
    }

    function saveColumns() {
      // Extract cohorts from draggable container
      const cohortsContainer = document.getElementById('cohortsContainer');
      const cohortItems = Array.from(cohortsContainer.querySelectorAll('.item-text')).map(el => el.textContent.trim());
      
      if (cohortItems.length === 0) {
        showToast('At least one cohort/column is required', 'error');
        return;
      }
      
      // Store old data before updating cohorts
      const oldData = JSON.parse(JSON.stringify(state.data));
      
      // Update cohorts with new order from drag-and-drop
      state.cohorts = cohortItems;
      
      // Migrate existing data to new cohort structure
      const newData = {};
      for (let day = 1; day <= state.daysInMonth; day++) {
        if (oldData[day]) {
          newData[day] = {};
          for (const cohort of state.cohorts) {
            if (oldData[day][cohort]) {
              // Preserve existing data for cohorts that still exist
              newData[day][cohort] = oldData[day][cohort];
            } else {
              // Initialize new cohorts with empty groups
              newData[day][cohort] = Array(4).fill().map(() => ({site: '', instructor: '', schedule: ''}));
            }
          }
        }
      }
      
      state.data = newData;
      
      // Close modal and re-render
      document.getElementById('columnsModal').style.display = 'none';
      render();
      
      // Auto-save the updated structure
      if (typeof autoSave === 'function') {
        autoSave();
      }
      
      showToast(`Columns updated successfully with your custom order! (${state.cohorts.length} cohorts)`, 'success');
    }

    function resetColumns() {
      if (confirm('Reset to default cohorts? This will restore the original column layout.\n\nExisting data for current cohorts will be preserved where possible.')) {
        const defaultCohorts = ["VN B111 (D)","VN B113 (D)","VN B108 (D)","VN B112 (E)","VN B107 (E)","VN B109 (E)","VN B103","VN B110 (10)","NATP/HHA","RN-BSN","Make Up","Admin"];
        
        // Update state temporarily for display
        state.cohorts = [...defaultCohorts];
        
        // Repopulate the draggable list
        populateDraggableCohorts();
        
        showToast('Reset to default cohorts - click Save Changes to apply', 'info');
      }
    }

    function closeColumns() {
      document.getElementById('columnsModal').style.display = 'none';
    }

    // Fullscreen Functions
    async function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.body.classList.add('fullscreen');
        await document.documentElement.requestFullscreen?.();
        document.getElementById('toggleFullBtn').textContent = 'Exit Full Screen';
      } else {
        await document.exitFullscreen?.();
      }
    }

    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        document.body.classList.remove('fullscreen');
        document.getElementById('toggleFullBtn').textContent = 'Enter Full Screen';
      }
    });

    // Admin Functions
    function enableAdminFeatures() {
      document.body.classList.add('admin-mode');
      showToast('Admin mode enabled', 'info');
    }

    // Function to update calendar when month or year changes
    function updateCalendar() {
      const monthSelect = document.getElementById('monthSelect');
      const abbr = monthSelect.value || '';
      const yr = parseInt(document.getElementById('yearInput').value || String(state.year), 10);
      
      // Update hidden field for backwards compatibility
      document.getElementById('monthAbbrev').value = abbr;
      
      // Don't proceed if no month is selected
      if (!abbr) {
        return;
      }
      
      // Validate month abbreviation
      const validMonths = ['JAN','FEB','MAR','APR','MAY','JUN','JUL','AUG','SEP','OCT','NOV','DEC'];
      if (!validMonths.includes(abbr)) {
        showToast('Please select a valid month', 'error');
        return;
      }
      
      // Validate year
      if (isNaN(yr) || yr < 2000 || yr > 2100) {
        showToast('Please enter a valid year between 2000 and 2100', 'error');
        return;
      }
      
      // Update state
      state.monthAbbrev = abbr;
      state.year = yr;
      state.daysInMonth = calcDaysInMonth(yr, abbr);
      
      // Preserve existing data for the new month
      const oldData = state.data;
      state.data = {};
      
      // Transfer any existing data to new month structure
      for (let day = 1; day <= state.daysInMonth; day++) {
        if (oldData[day]) {
          state.data[day] = oldData[day];
        }
      }
      
      render();
      
      // Auto-save calendar changes
      autoSave();
      
      showToast(`Calendar updated to ${abbr} ${yr}`, 'success');
    }

    // Event Listeners

    document.getElementById('toggleFullBtn').addEventListener('click', toggleFullscreen);
    document.getElementById('manageDropdowns').addEventListener('click', openLists);
    document.getElementById('saveLists').addEventListener('click', saveLists);
    document.getElementById('closeLists').addEventListener('click', closeLists);
    document.getElementById('manageColumns').addEventListener('click', openColumns);
    document.getElementById('saveColumns').addEventListener('click', saveColumns);
    document.getElementById('resetColumns').addEventListener('click', resetColumns);
    document.getElementById('closeColumns').addEventListener('click', closeColumns);
    
    // Enhanced search functionality
    const searchInput = document.getElementById('search');
    const clearButton = document.getElementById('searchClear');
    const resultsInfo = document.getElementById('searchResults');
    
    // ENHANCED SEARCH EVENT HANDLERS
    function performEnhancedSearch() {
      const searchTerm = searchInput.value.trim();
      const tbody = document.querySelector('#tableWrap table tbody');
      
      if (tbody) {
        if (searchTerm === '') {
          // Clear search - show all rows
          Array.from(tbody.rows).forEach(row => {
            row.style.display = '';
            row.classList.remove('table-row-highlighted');
          });
          clearSearchHighlights();
          updateSearchStats(0, 0, 0, tbody.rows.length);
        } else {
          // Perform enhanced search
          enhancedSearch(searchTerm, tbody);
        }
      }
    }

    // Real-time search with optimized debouncing
    let searchTimeout;
    searchInput.addEventListener('input', function() {
      clearTimeout(searchTimeout);
      
      // Immediate visual feedback for fast typing
      const searchTerm = this.value.trim();
      if (searchTerm === '') {
        performEnhancedSearch();
      } else {
        // Debounce for better performance during typing
        searchTimeout = setTimeout(() => {
          performEnhancedSearch();
        }, 150);
      }
    });
    
    // Enhanced clear search functionality
    clearButton.addEventListener('click', function() {
      searchInput.value = '';
      searchInput.classList.remove('has-results', 'no-results');
      performEnhancedSearch();
      searchInput.focus();
      
      // Smooth scroll to top after clearing
      document.querySelector('.table-container').scrollIntoView({ 
        behavior: 'smooth', 
        block: 'start' 
      });
    });
    
    // Enhanced keyboard navigation and shortcuts
    searchInput.addEventListener('keydown', function(e) {
      if (e.key === 'Escape') {
        // Escape key - clear search
        this.value = '';
        this.classList.remove('has-results', 'no-results');
        performEnhancedSearch();
        this.blur(); // Remove focus after clearing
      } else if (e.key === 'Enter') {
        // Enter key - focus on first visible row (if any)
        e.preventDefault();
        const firstVisibleRow = document.querySelector('tbody tr:not([style*="display: none"])');
        if (firstVisibleRow) {
          firstVisibleRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
      }
    });

    // Global keyboard shortcut: Ctrl+F to focus search
    document.addEventListener('keydown', function(e) {
      if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
        e.preventDefault();
        searchInput.focus();
        searchInput.select();
      }
    });
    document.getElementById('exportCsvBtn').addEventListener('click', exportCsv);
    document.getElementById('exportXlsxBtn').addEventListener('click', exportXlsx);
    document.getElementById('exportPdfBtn').addEventListener('click', exportPdf);
    document.getElementById('exportNormalizedCsvBtn').addEventListener('click', exportNormalizedCsv);

    // Import Functions
    function handleImport(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = new Uint8Array(e.target.result);
          const workbook = XLSX.read(data, {type: 'array'});
          const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
          const rows = XLSX.utils.sheet_to_json(firstSheet, {header: 1});
          
          // Normalize text function
          function _norm(x) { 
            return String(x == null ? '' : x).replace(/\u00A0/g, ' ').replace(/\s+/g, ' ').trim(); 
          }

          // Find header row with improved detection
          const MONTH_RX = /(^|\b)(month|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|day|date)\b/i;
          const ITEM_RX = /(^|\b)item\s*#?\b/i;
          let headerRow = -1, itemIdx = -1, monthIdx = -1, header = null;

          for(let r = 0; r < Math.min(60, rows.length); r++) {
            const row = (rows[r] || []).map(_norm);
            const i = row.findIndex(h => ITEM_RX.test(h));
            if(i !== -1) {
              let m = row.findIndex(h => MONTH_RX.test(h));
              if(m === -1) {
                m = row.findIndex(h => /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)$/i.test(h));
              }
              if(m !== -1) {
                headerRow = r;
                itemIdx = i;
                monthIdx = m;
                header = row;
                break;
              }
            }
          }

          if(headerRow < 0) {
            showToast('Could not locate the header row. Need "ITEM #" and Month/Day.', 'error');
            return;
          }

          // Parse cohorts (all headers except ITEM & Month)
          const cohorts = header
            .map((h, i) => ({h: _norm(h), i}))
            .filter(x => x.i !== itemIdx && x.i !== monthIdx && x.h)
            .map(x => x.h);

          if(!cohorts.length) {
            showToast('No cohort columns found in file', 'error');
            return;
          }

          // Update state with new cohorts
          state.cohorts = cohorts.slice();
          state.data = {};

          // Get current month/year context
          const monAbbr = (document.getElementById('monthAbbrev').value || 'NOV').toUpperCase().slice(0, 3);
          const yearVal = parseInt(document.getElementById('yearInput').value || '2025', 10) || 2025;
          const maxDays = calcDaysInMonth(yearVal, monAbbr);

          // Setup column index mapping
          const colIndex = Object.fromEntries(cohorts.map(c => [c, header.indexOf(c)]));
          
          // Initialize data structure
          for(let d = 1; d <= maxDays; d++) {
            state.data[d] = {};
            for(const c of cohorts) {
              state.data[d][c] = Array(4).fill().map(() => ({site: '', instructor: '', schedule: ''}));
            }
          }

          // Helper function to append values
          function append(prev, val) {
            if(!val) return prev;
            return prev ? (prev + ' | ' + val) : val;
          }

          // Parse data rows with improved handling
          let currentDay = 1;
          const groupIdx = {};
          for(let d = 1; d <= maxDays; d++) { groupIdx[d] = 0; }

          for(let r = headerRow + 1; r < rows.length; r++) {
            const row = rows[r] || [];
            
            // Update day when found in month column
            const dcell = _norm(row[monthIdx]);
            const dm = dcell.match(/(\d{1,2})/);
            if(dm) {
              currentDay = parseInt(dm[1], 10);
            }
            if(!currentDay || currentDay < 1 || currentDay > maxDays) continue;

            // Parse item number and determine row type
            const iraw = _norm(row[itemIdx]);
            if(!iraw) continue;
            const inum = parseInt(iraw.replace(/[^0-9]/g, ''), 10);
            if(!inum) continue;
            const mod = inum % 4; // 1=site, 2=instructor, 3=schedule, 0=separator

            if(mod === 0) {
              groupIdx[currentDay] = Math.min(3, groupIdx[currentDay] + 1);
              continue;
            }

            // Get current group index
            const g = Math.min(groupIdx[currentDay], 3);

            // Process each cohort's data
            for(const c of cohorts) {
              const ci = colIndex[c];
              const val = (ci >= 0 && ci < row.length) ? _norm(row[ci]) : '';
              if(!val) continue;

              const rec = state.data[currentDay][c][g];
              
              if(mod === 1) {
                rec.site = append(rec.site, val);
              } else if(mod === 2) {
                rec.instructor = append(rec.instructor, val);
              } else if(mod === 3) {
                rec.schedule = append(rec.schedule, val);
              }
            }
          }

          // DON'T ADD ANYTHING TO DROPDOWN LISTS FROM IMPORT
          // Keep the original dropdown lists exactly as they are

          // Update month/year inputs to match imported data if needed
          const firstMonthCell = rows[headerRow + 1]?.[monthIdx];
          if(firstMonthCell) {
            const monthMatch = firstMonthCell.toString().match(/[A-Za-z]{3}/i);
            if(monthMatch) {
              const monthAbbr = monthMatch[0].toUpperCase();
              document.getElementById('monthAbbrev').value = monthAbbr;
              document.getElementById('monthSelect').value = monthAbbr;
            }
          }

          render();
          
          // Auto-save imported data
          autoSave();
          
          showToast('File imported successfully', 'success');
        } catch(e) {
          console.error('Import error:', e);
          showToast('Error importing file: ' + e.message, 'error');
        }
      };
      reader.readAsArrayBuffer(file);
    }

    // Wire up import button
    document.getElementById('importXlsxBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(file) {
        handleImport(file);
      }
      e.target.value = ''; // Reset input
    });

    // Admin Authentication with Session Persistence
    const ADMIN_PASSWORD = 'admin123'; // Change this to your desired password
    let isAdminMode = false;

    function showAdminAuth() {
      document.getElementById('adminAuthModal').style.display = 'block';
      document.getElementById('adminPassword').focus();
    }

    function closeAdminAuth() {
      document.getElementById('adminAuthModal').style.display = 'none';
      document.getElementById('adminPassword').value = '';
    }

    function enableAdminMode() {
      isAdminMode = true;
      document.body.classList.add('admin-mode');
      document.getElementById('adminToolbar').style.display = 'flex';
      
      // Save admin session to sessionStorage (persists through refresh, cleared when tab closes)
      sessionStorage.setItem('admin_session', 'authenticated');
      
      closeAdminAuth();
      showToast('Admin mode enabled', 'success');
    }

    function disableAdminMode() {
      isAdminMode = false;
      document.body.classList.remove('admin-mode');
      document.getElementById('adminToolbar').style.display = 'none';
      
      // Clear admin session from sessionStorage
      sessionStorage.removeItem('admin_session');
      
      showToast('Logged out of admin mode', 'info');
    }

    function checkAdminSession() {
      // Check sessionStorage for admin session (persists through refresh, cleared when tab closes)
      const adminSession = sessionStorage.getItem('admin_session');
      
      if (adminSession === 'authenticated') {
        // Restore admin mode
        isAdminMode = true;
        document.body.classList.add('admin-mode');
        document.getElementById('adminToolbar').style.display = 'flex';
        return true;
      } else {
        // Start in normal user mode
        isAdminMode = false;
        document.body.classList.remove('admin-mode');
        document.getElementById('adminToolbar').style.display = 'none';
        return false;
      }
    }

    document.getElementById('adminLoginBtn').addEventListener('click', () => {
      const password = document.getElementById('adminPassword').value;
      if (password === ADMIN_PASSWORD) {
        enableAdminMode();
      } else {
        showToast('Invalid password', 'error');
      }
    });

    document.getElementById('adminPassword').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        document.getElementById('adminLoginBtn').click();
      }
    });

    // Admin Features







    // Clear all data function
    function clearAllData() {
      if (confirm('Are you sure you want to clear ALL data? This cannot be undone!\n\nThis will clear:\n- All schedule entries\n- All imported data\n- Month/year settings\n\nNote: Dropdown lists and cohorts/columns will be preserved.\n\nClick OK to proceed or Cancel to abort.')) {
        try {
          // Clear both localStorage and sessionStorage calendar data (but preserve lists and cohorts)
          localStorage.removeItem('sched_state_v9');
          localStorage.removeItem('sched_state_auto_v9');
          sessionStorage.removeItem('sched_state_session_v9');
          localStorage.removeItem('sched_last_save');
          
          // Preserve existing cohorts from localStorage
          const savedCohorts = localStorage.getItem('sched_cohorts_v9');
          let preservedCohorts = ["VN B111 (D)","VN B113 (D)","VN B108 (D)","VN B112 (E)","VN B107 (E)","VN B109 (E)","VN B103","VN B110 (10)","NATP/HHA","RN-BSN","Make Up","Admin"];
          
          if(savedCohorts) {
            try {
              const parsedCohorts = JSON.parse(savedCohorts);
              if(parsedCohorts && Array.isArray(parsedCohorts) && parsedCohorts.length > 0) {
                preservedCohorts = parsedCohorts;
              }
            } catch(e) {
              console.log('Could not restore saved cohorts during clear, using defaults');
            }
          }
          
          // Preserve currently selected month and year
          const preservedMonth = document.getElementById('monthSelect').value;
          const preservedYear = parseInt(document.getElementById('yearInput').value) || 2025;
          
          // Reset state to defaults (preserve lists, cohorts, and current month/year selection)
          state = {
            monthAbbrev: preservedMonth,
            year: preservedYear,
            daysInMonth: 30,
            cohorts: preservedCohorts,
            groupsPerDay: 4,
            data: {}
          };
          
          // Keep existing dropdown lists intact - DO NOT reset them
          // Keep existing cohorts intact - DO NOT reset them
          
          // Preserve currently selected month and year before clearing
          const selectedMonth = document.getElementById('monthSelect').value;
          const selectedYear = document.getElementById('yearInput').value;
          
          // Reset form fields but preserve month selection
          document.getElementById('monthAbbrev').value = selectedMonth;
          document.getElementById('monthSelect').value = selectedMonth;
          document.getElementById('yearInput').value = selectedYear || "2025";
          
          // Re-render with clean data
          render();
          
          showToast('Calendar data cleared successfully (dropdown lists and cohorts preserved)', 'success');
        } catch(e) {
          console.error('Error clearing data:', e);
          showToast('Error clearing data: ' + e.message, 'error');
        }
      }
    }

    // Wire up admin buttons
    document.getElementById('adminLogoutBtn')?.addEventListener('click', disableAdminMode);

    // Show admin login button (floating in bottom right)
    const adminLoginFab = document.createElement('button');
    adminLoginFab.id = 'adminLoginFab';
    adminLoginFab.className = 'btn btn-primary';
    adminLoginFab.style.cssText = 'position:fixed;bottom:20px;right:20px;z-index:999;border-radius:50%;width:50px;height:50px;display:flex;align-items:center;justify-content:center;box-shadow:var(--shadow-lg);';
    adminLoginFab.innerHTML = 'üîê';
    adminLoginFab.onclick = showAdminAuth;
    document.body.appendChild(adminLoginFab);

    // Admin Button Functions
    
    // Import CSV Function
    function handleCsvImport(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const text = e.target.result;
          const rows = text.split(/\\r?\\n/).map(row => 
            row.split(',').map(cell => 
              cell.replace(/^"(.*)"$/, '$1').replace(/""/g, '"').trim()
            )
          );

          // Find header row
          let headerRow = -1;
          const MONTH_RX = /(^|\b)(month|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|day|date)\b/i;
          const ITEM_RX = /(^|\b)item\s*#?\b/i;
          
          for(let r = 0; r < Math.min(20, rows.length); r++) {
            const row = rows[r];
            const itemIdx = row.findIndex(h => ITEM_RX.test(h));
            if(itemIdx !== -1) {
              const monthIdx = row.findIndex(h => MONTH_RX.test(h));
              if(monthIdx !== -1) {
                headerRow = r;
                // Parse cohorts (all headers except ITEM & Month)
                const cohorts = row.filter((h, i) => 
                  i !== itemIdx && i !== monthIdx && h.trim()
                );
                
                if(cohorts.length) {
                  // Update state
                  state.cohorts = cohorts;
                  state.data = {};
                  
                  // Process data rows
                  let currentDay = 1;
                  let groupIndex = 0;
                  
                  for(let i = headerRow + 1; i < rows.length; i++) {
                    const row = rows[i];
                    if(!row.length) continue;
                    
                    // Check for day in month column
                    const dayMatch = row[monthIdx]?.match(/^\s*(\d+)/);
                    if(dayMatch) {
                      currentDay = parseInt(dayMatch[1], 10);
                      if(currentDay < 1 || currentDay > 31) continue;
                    }
                    
                    // Parse item number
                    const itemNum = parseInt(row[itemIdx]?.replace(/\D/g, '') || '0', 10);
                    if(!itemNum) continue;
                    
                    const rowType = itemNum % 4; // 1=site, 2=instructor, 3=schedule, 0=separator
                    
                    if(rowType === 0) {
                      groupIndex = Math.min(3, groupIndex + 1);
                      continue;
                    }
                    
                    // Process each cohort's data
                    cohorts.forEach((cohort, idx) => {
                      const value = row[idx + 2]?.trim() || '';
                      if(!value) return;
                      
                      const record = ensureGroup(currentDay, cohort, groupIndex);
                      
                      if(rowType === 1) {
                        record.site = value;
                      } else if(rowType === 2) {
                        record.instructor = value;
                      } else if(rowType === 3) {
                        record.schedule = value;
                      }
                    });
                  }
                  
                  render();
                  
                  // Auto-save imported CSV data
                  autoSave();
                  
                  showToast('CSV imported successfully', 'success');
                  return;
                }
              }
            }
          }
          throw new Error('Invalid CSV format');
        } catch(e) {
          console.error('CSV import error:', e);
          showToast('Error importing CSV: ' + e.message, 'error');
        }
      };
      reader.readAsText(file);
    }



    
    // Test function to debug current data state
    function testCurrentData() {
      const info = [];
      
      try {
        // Check current state
        info.push(`State exists: ${!!state}`);
        info.push(`State type: ${typeof state}`);
        
        if (state) {
          info.push(`State keys: ${Object.keys(state).join(', ')}`);
          info.push(`Schedule exists: ${!!state.schedule}`);
          if (state.schedule) {
            info.push(`Schedule entries: ${Object.keys(state.schedule).length}`);
          }
          info.push(`Month: ${state.monthAbbrev || 'Not set'}`);
          info.push(`Year: ${state.year || 'Not set'}`);
        }
        
        // Check lists
        info.push(`Lists exist: ${!!lists}`);
        if (lists) {
          info.push(`Lists keys: ${Object.keys(lists).join(', ')}`);
        }
        
        // Test JSON serialization
        try {
          const testJson = JSON.stringify(state);
          info.push(`JSON serialization: SUCCESS (${testJson.length} chars)`);
        } catch(jsonError) {
          info.push(`JSON serialization: FAILED - ${jsonError.message}`);
        }
        
        console.log('=== CURRENT DATA TEST ===');
        info.forEach(line => console.log(line));
        console.log('=== END TEST ===');
        
        alert('Data Test Results:\n\n' + info.join('\n\n') + '\n\nCheck console for full details.');
        
      } catch(error) {
        const errorInfo = `Test failed: ${error.message}`;
        console.error(errorInfo, error);
        alert(errorInfo);
      }
    }

    // Wire up admin buttons
    document.getElementById('importCsvBtn').addEventListener('click', () => {
      document.getElementById('csvFileInput').click();
    });

    document.getElementById('csvFileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if(file) {
        handleCsvImport(file);
      }
      e.target.value = ''; // Reset input
    });

    // Wire up the main clear data button (available to all users)
    document.getElementById('clearAllDataBtnMain').addEventListener('click', clearAllData);

    // Auto-save function - minimal session backup only
    function autoSave() {
      try {
        // Only save to sessionStorage for session recovery - no file management
        sessionStorage.setItem('nursing_session_backup', JSON.stringify(state));
      } catch(error) {
        console.error('Session backup failed:', error);
      }
    }

    // Auto-restore function - restores calendar data from sessionStorage and dropdown lists + cohorts from localStorage
    function autoRestore() {
      try {
        // First restore cohorts from localStorage (permanent persistence - survives browser/file close)
        const savedCohorts = localStorage.getItem('sched_cohorts_v9');
        if(savedCohorts) {
          try {
            const parsedCohorts = JSON.parse(savedCohorts);
            if(parsedCohorts && Array.isArray(parsedCohorts) && parsedCohorts.length > 0) {
              state.cohorts = parsedCohorts;
            }
          } catch(e) {
            console.log('Could not restore saved cohorts, using defaults');
          }
        }
        
        // Restore calendar data from sessionStorage (persists through refresh, cleared when tab closes)
        const savedState = sessionStorage.getItem('sched_state_session_v9');
        if(savedState) {
          try {
            const parsedState = JSON.parse(savedState);
            if(parsedState && typeof parsedState === 'object') {
              // Restore calendar state (but NOT cohorts - they come from localStorage)
              if(parsedState.monthAbbrev) state.monthAbbrev = parsedState.monthAbbrev;
              if(parsedState.year) state.year = parsedState.year;
              if(parsedState.daysInMonth) state.daysInMonth = parsedState.daysInMonth;
              if(parsedState.groupsPerDay) state.groupsPerDay = parsedState.groupsPerDay;
              if(parsedState.data) state.data = parsedState.data;
              
              // Update form fields to match restored state
              if(state.monthAbbrev) {
                document.getElementById('monthAbbrev').value = state.monthAbbrev;
                document.getElementById('monthSelect').value = state.monthAbbrev;
              }
              if(state.year) {
                document.getElementById('yearInput').value = state.year;
              }
            }
          } catch(e) {
            console.log('Could not restore saved calendar data, using defaults');
          }
        }
        
        // Preserve dropdown lists from localStorage (permanent persistence for user customizations)
        const savedLists = localStorage.getItem('sched_lists_v9');
        if(savedLists) {
          try {
            const parsedLists = JSON.parse(savedLists);
            // Only restore if it has valid structure
            if(parsedLists && parsedLists.sites && parsedLists.instructors && parsedLists.schedule) {
              lists.sites = parsedLists.sites;
              lists.instructors = parsedLists.instructors;
              lists.schedule = parsedLists.schedule;
            }
          } catch(e) {
            console.log('Could not restore saved lists, using defaults');
          }
        }
        
      } catch(e) {
        console.error('Auto-restore error:', e);
      }
    }

    // Add keyboard shortcut to access admin login (Ctrl+Shift+A or Cmd+Shift+A)
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'A') {
        e.preventDefault();
        showAdminAuth();
        showToast('Admin login opened via keyboard shortcut', 'info');
      }
    });

    // Check for existing admin session on page load (always starts normal)
    checkAdminSession();

    // Auto-restore data on page load (preserves custom dropdown lists)
    autoRestore();

    // Initial render
    render();
    
    // Update conflict indicators after initial render
    setTimeout(() => {
      updateConflictIndicators();
    }, 500);

    // FACULTY CONFLICT DETECTION SYSTEM
    function parseScheduleTime(scheduleString) {
      if (!scheduleString) return null;
      
      // Common schedule patterns to parse
      const timePatterns = [
        /^(\d{1,2}):?(\d{2})-(\d{1,2}):?(\d{2})$/,  // 7:00-15:30 or 0700-1530
        /^(\d{3,4})-(\d{3,4})$/,                     // 700-1530
        /^(\d{1,2})-(\d{1,2})$/                      // 7-15
      ];
      
      for (const pattern of timePatterns) {
        const match = scheduleString.match(pattern);
        if (match) {
          let startHour, startMin, endHour, endMin;
          
          if (pattern === timePatterns[0]) {
            // HH:MM-HH:MM format
            startHour = parseInt(match[1]);
            startMin = parseInt(match[2]);
            endHour = parseInt(match[3]);
            endMin = parseInt(match[4]);
          } else if (pattern === timePatterns[1]) {
            // HHMM-HHMM format
            const start = match[1].padStart(4, '0');
            const end = match[2].padStart(4, '0');
            startHour = parseInt(start.substring(0, 2));
            startMin = parseInt(start.substring(2, 4));
            endHour = parseInt(end.substring(0, 2));
            endMin = parseInt(end.substring(2, 4));
          } else {
            // H-H format (assume full hours)
            startHour = parseInt(match[1]);
            startMin = 0;
            endHour = parseInt(match[2]);
            endMin = parseInt(match[4]) || 0;
          }
          
          return {
            start: startHour * 60 + startMin,
            end: endHour * 60 + endMin
          };
        }
      }
      
      return null;
    }

    function getConflictSettings() {
      const settings = JSON.parse(localStorage.getItem('conflictSettings') || '{}');
      return {
        bufferMinutes: settings.bufferMinutes || 30,
        strictMode: settings.strictMode !== false,
        allowSameDay: settings.allowSameDay !== false,
        showWarnings: settings.showWarnings !== false
      };
    }

    function checkTimeOverlap(time1, time2, customBuffer = null) {
      if (!time1 || !time2) return false;
      
      const settings = getConflictSettings();
      const bufferMinutes = customBuffer !== null ? customBuffer : settings.bufferMinutes;
      
      // Add buffer time to check for conflicts
      const t1Start = time1.start - bufferMinutes;
      const t1End = time1.end + bufferMinutes;
      const t2Start = time2.start;
      const t2End = time2.end;
      
      // Check for overlap
      return (t1Start < t2End && t1End > t2Start);
    }

    function getTimeString(minutes) {
      const hours = Math.floor(minutes / 60);
      const mins = minutes % 60;
      const period = hours >= 12 ? 'PM' : 'AM';
      const displayHours = hours > 12 ? hours - 12 : (hours === 0 ? 12 : hours);
      return `${displayHours}:${mins.toString().padStart(2, '0')} ${period}`;
    }

    function findInstructorConflicts(instructor, day, currentCohort, currentGroup) {
      if (!instructor || instructor === '' || instructor === 'Clear') return [];
      
      const conflicts = [];
      
      // Check all assignments for the same day
      for (let g = 0; g < state.groupsPerDay; g++) {
        state.cohorts.forEach(cohort => {
          // Skip the current assignment being checked
          if (cohort === currentCohort && g === currentGroup) return;
          
          const assignment = ensureGroup(day, cohort, g);
          if (assignment.instructor === instructor) {
            // Found the same instructor assigned elsewhere
            const currentSchedule = ensureGroup(day, currentCohort, currentGroup).schedule;
            const conflictSchedule = assignment.schedule;
            
            const currentTime = parseScheduleTime(currentSchedule);
            const conflictTime = parseScheduleTime(conflictSchedule);
            
            const hasTimeConflict = checkTimeOverlap(currentTime, conflictTime);
            
            conflicts.push({
              cohort: cohort,
              group: g + 1,
              site: assignment.site,
              schedule: conflictSchedule,
              hasTimeConflict: hasTimeConflict,
              timeDetails: {
                current: currentTime,
                conflict: conflictTime
              },
              travelTime: hasTimeConflict ? 'Insufficient travel time between locations' : 'Same day, different times'
            });
          }
        });
      }
      
      return conflicts;
    }

    function showConflictDialog(instructor, conflicts, onConfirm, onCancel) {
      // Create modal
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 600px;">
          <div class="modal-header">
            <h3 class="modal-title">‚ö†Ô∏è Faculty Assignment Conflict</h3>
          </div>
          <div class="modal-body">
            <p><strong>${instructor}</strong> is already assigned to other locations on the same day:</p>
            <div class="conflict-list" style="margin: 1rem 0;">
              ${conflicts.map(conflict => `
                <div class="conflict-item" style="
                  padding: 0.75rem; 
                  margin: 0.5rem 0; 
                  border-left: 4px solid ${conflict.hasTimeConflict ? '#ef4444' : '#f59e0b'}; 
                  background: ${conflict.hasTimeConflict ? '#fef2f2' : '#fffbeb'};
                  border-radius: 0.375rem;
                ">
                  <div style="font-weight: bold; color: ${conflict.hasTimeConflict ? '#dc2626' : '#d97706'};">
                    ${conflict.hasTimeConflict ? 'üö´ Time Conflict' : '‚ö†Ô∏è Same Day Assignment'}
                  </div>
                  <div style="margin-top: 0.25rem;">
                    <strong>${conflict.cohort}</strong> - Group ${conflict.group}
                  </div>
                  <div style="font-size: 0.875rem; color: var(--text-muted);">
                    Site: ${conflict.site}<br>
                    Time: ${conflict.schedule}
                  </div>
                  <div style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.25rem;">
                    ${conflict.travelTime}
                  </div>
                </div>
              `).join('')}
            </div>
            <div class="conflict-actions" style="
              padding: 1rem; 
              background: #f9fafb; 
              border-radius: 0.375rem; 
              margin: 1rem 0;
            ">
              <p style="margin-bottom: 1rem; font-weight: 500;">What would you like to do?</p>
              <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                <button onclick="handleConflictConfirm()" class="btn btn-warning" style="font-size: 0.875rem;">
                  Continue Anyway
                </button>
                <button onclick="handleConflictCancel()" class="btn btn-secondary" style="font-size: 0.875rem;">
                  Cancel Assignment
                </button>
                <button onclick="suggestAlternative('${instructor}', ${JSON.stringify(conflicts).replace(/"/g, '&quot;')})" class="btn btn-info" style="font-size: 0.875rem;">
                  Suggest Alternative
                </button>
                <button onclick="showDetailedConflicts('${instructor}')" class="btn btn-primary" style="font-size: 0.875rem;">
                  View All Assignments
                </button>
              </div>
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Global functions for conflict modal
      window.handleConflictConfirm = () => {
        document.body.removeChild(modal);
        if (onConfirm) onConfirm();
      };
      
      window.handleConflictCancel = () => {
        document.body.removeChild(modal);
        if (onCancel) onCancel();
      };
    }

    function suggestAlternativeInstructor(currentInstructor, conflicts) {
      // Get all available instructors excluding the current one and empty options
      const availableInstructors = state.lists.instructors.filter(inst => 
        inst !== currentInstructor && 
        inst !== '' && 
        inst !== 'Custom' && 
        inst !== 'Clear' && 
        inst.trim() !== ''
      );
      
      if (availableInstructors.length === 0) {
        showToast('No alternative instructors available', 'warning');
        return;
      }
      
      // Calculate workload for each instructor
      const instructorWorkload = availableInstructors.map(instructor => {
        let assignmentCount = 0;
        let conflictCount = 0;
        
        for (let day = 1; day <= state.daysInMonth; day++) {
          for (let g = 0; g < state.groupsPerDay; g++) {
            state.cohorts.forEach(cohort => {
              const assignment = ensureGroup(day, cohort, g);
              if (assignment.instructor === instructor) {
                assignmentCount++;
                const instructorConflicts = findInstructorConflicts(instructor, day, cohort, g);
                conflictCount += instructorConflicts.length;
              }
            });
          }
        }
        
        return {
          name: instructor,
          assignments: assignmentCount,
          conflicts: conflictCount,
          score: assignmentCount + (conflictCount * 2) // Penalize conflicts more
        };
      });
      
      // Sort by workload (lower score = better choice)
      instructorWorkload.sort((a, b) => a.score - b.score);
      
      // Create suggestion modal
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <div class="modal-header">
            <h3 class="modal-title">üí° Alternative Instructor Suggestions</h3>
            <button onclick="closeSuggestionModal()" class="btn btn-secondary">&times;</button>
          </div>
          <div class="modal-body">
            <p style="margin-bottom: 1rem;">Based on current workload and conflicts, here are the best alternatives:</p>
            <div style="max-height: 300px; overflow-y: auto;">
              ${instructorWorkload.slice(0, 5).map((inst, index) => `
                <div class="suggestion-item" style="
                  padding: 0.75rem; 
                  margin: 0.5rem 0; 
                  border: 1px solid var(--border); 
                  border-radius: 0.375rem; 
                  cursor: pointer;
                  ${index === 0 ? 'border-color: var(--success); background: #f0fdf4;' : ''}
                " onclick="selectSuggestedInstructor('${inst.name}')">
                  <div style="font-weight: bold; color: var(--primary);">
                    ${index === 0 ? '‚≠ê ' : ''}${inst.name}
                    ${index === 0 ? ' (Recommended)' : ''}
                  </div>
                  <div style="font-size: 0.875rem; color: var(--text-muted);">
                    Current assignments: ${inst.assignments} | Conflicts: ${inst.conflicts}
                  </div>
                </div>
              `).join('')}
            </div>
            <div style="margin-top: 1rem; padding: 0.75rem; background: #fef3c7; border-radius: 0.375rem;">
              <div style="font-size: 0.875rem; color: #92400e;">
                üí° <strong>Tip:</strong> Click on any instructor above to auto-select them in the dropdown.
              </div>
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Global functions for suggestion modal
      window.selectSuggestedInstructor = (instructor) => {
        showToast(`Alternative instructor "${instructor}" suggested. Please manually select from the dropdown.`, 'info');
        closeSuggestionModal();
      };
      
      window.closeSuggestionModal = () => {
        document.body.removeChild(modal);
      };
    }

    function showInstructorConflictDetails(instructor) {
      // Collect all conflicts for this instructor across all days
      const allConflicts = [];
      
      for (let day = 1; day <= state.daysInMonth; day++) {
        const dayConflicts = [];
        for (let g = 0; g < state.groupsPerDay; g++) {
          state.cohorts.forEach(cohort => {
            const assignment = ensureGroup(day, cohort, g);
            if (assignment.instructor === instructor) {
              dayConflicts.push({
                cohort: cohort,
                group: g + 1,
                site: assignment.site,
                schedule: assignment.schedule,
                day: day
              });
            }
          });
        }
        if (dayConflicts.length > 1) {
          allConflicts.push({ day, assignments: dayConflicts });
        }
      }
      
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 700px;">
          <div class="modal-header">
            <h3 class="modal-title">üìã All Assignments: ${instructor}</h3>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">&times;</button>
          </div>
          <div class="modal-body">
            ${allConflicts.length === 0 ? `
              <div style="text-align: center; padding: 2rem; color: #059669;">
                <div style="font-size: 3rem;">‚úÖ</div>
                <h4>No Multiple Assignments</h4>
                <p>${instructor} has no days with multiple assignments.</p>
              </div>
            ` : `
              <p><strong>${instructor}</strong> has multiple assignments on ${allConflicts.length} day(s):</p>
              <div style="max-height: 400px; overflow-y: auto; margin: 1rem 0;">
                ${allConflicts.map(dayConflict => `
                  <div style="margin: 1rem 0; padding: 1rem; border: 1px solid var(--border); border-radius: 0.5rem;">
                    <h5 style="margin-bottom: 0.5rem; color: var(--primary);">
                      Day ${dayConflict.day} (${weekday(state.year, state.monthAbbrev, dayConflict.day)})
                    </h5>
                    ${dayConflict.assignments.map(assignment => `
                      <div style="padding: 0.5rem; margin: 0.25rem 0; background: #f8f9fa; border-radius: 0.25rem;">
                        <strong>${assignment.cohort}</strong> - Group ${assignment.group}<br>
                        <span style="font-size: 0.875rem; color: var(--text-muted);">
                          Site: ${assignment.site} | Time: ${assignment.schedule}
                        </span>
                      </div>
                    `).join('')}
                  </div>
                `).join('')}
              </div>
            `}
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
    }

    function showConflictSettings() {
      // Get current settings or defaults
      const currentSettings = JSON.parse(localStorage.getItem('conflictSettings') || '{}');
      const settings = {
        bufferMinutes: currentSettings.bufferMinutes || 30,
        strictMode: currentSettings.strictMode !== false, // Default true
        allowSameDay: currentSettings.allowSameDay !== false, // Default true
        showWarnings: currentSettings.showWarnings !== false // Default true
      };
      
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 550px;">
          <div class="modal-header">
            <h3 class="modal-title">‚öôÔ∏è Conflict Detection Settings</h3>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">&times;</button>
          </div>
          <div class="modal-body">
            <div class="form-group" style="margin-bottom: 1.5rem;">
              <label style="font-weight: bold; margin-bottom: 0.5rem; display: block;">
                Travel Time Buffer (minutes)
              </label>
              <input type="number" id="bufferMinutes" value="${settings.bufferMinutes}" min="0" max="120" 
                     style="width: 100%; padding: 0.5rem; border: 1px solid var(--border); border-radius: 0.375rem;">
              <div style="font-size: 0.875rem; color: var(--text-muted); margin-top: 0.25rem;">
                Minimum time between assignments (0-120 minutes). Recommended: 30 minutes.
              </div>
            </div>
            
            <div class="form-group" style="margin-bottom: 1.5rem;">
              <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                <input type="checkbox" id="strictMode" ${settings.strictMode ? 'checked' : ''}
                       style="width: 1rem; height: 1rem;">
                <span style="font-weight: bold;">Strict Conflict Detection</span>
              </label>
              <div style="font-size: 0.875rem; color: var(--text-muted); margin-top: 0.25rem; margin-left: 1.5rem;">
                Block assignments that would create time conflicts (recommended for clinical sites)
              </div>
            </div>
            
            <div class="form-group" style="margin-bottom: 1.5rem;">
              <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                <input type="checkbox" id="allowSameDay" ${settings.allowSameDay ? 'checked' : ''}
                       style="width: 1rem; height: 1rem;">
                <span style="font-weight: bold;">Allow Same-Day Assignments</span>
              </label>
              <div style="font-size: 0.875rem; color: var(--text-muted); margin-top: 0.25rem; margin-left: 1.5rem;">
                Permit multiple assignments on the same day (with time buffer consideration)
              </div>
            </div>
            
            <div class="form-group" style="margin-bottom: 1.5rem;">
              <label style="display: flex; align-items: center; gap: 0.5rem; cursor: pointer;">
                <input type="checkbox" id="showWarnings" ${settings.showWarnings ? 'checked' : ''}
                       style="width: 1rem; height: 1rem;">
                <span style="font-weight: bold;">Show Conflict Warnings</span>
              </label>
              <div style="font-size: 0.875rem; color: var(--text-muted); margin-top: 0.25rem; margin-left: 1.5rem;">
                Display visual indicators and warnings for potential conflicts
              </div>
            </div>
            
            <div class="btn-group" style="justify-content: space-between; margin-top: 2rem;">
              <button onclick="resetConflictSettings()" class="btn btn-secondary">Reset to Defaults</button>
              <div style="display: flex; gap: 0.5rem;">
                <button onclick="saveConflictSettings()" class="btn btn-primary">Save Settings</button>
                <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">Cancel</button>
              </div>
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Global functions for settings modal
      window.saveConflictSettings = () => {
        const newSettings = {
          bufferMinutes: parseInt(document.getElementById('bufferMinutes').value) || 30,
          strictMode: document.getElementById('strictMode').checked,
          allowSameDay: document.getElementById('allowSameDay').checked,
          showWarnings: document.getElementById('showWarnings').checked
        };
        
        localStorage.setItem('conflictSettings', JSON.stringify(newSettings));
        showToast('Conflict settings saved successfully', 'success');
        updateConflictIndicators(); // Refresh with new settings
        document.querySelector('.modal').remove();
      };
      
      window.resetConflictSettings = () => {
        document.getElementById('bufferMinutes').value = 30;
        document.getElementById('strictMode').checked = true;
        document.getElementById('allowSameDay').checked = true;
        document.getElementById('showWarnings').checked = true;
        showToast('Settings reset to defaults', 'info');
      };
    }

    // Global Conflict Management
    function updateConflictIndicators() {
      // Clear existing conflict indicators
      document.querySelectorAll('.instructor-conflict, .instructor-warning').forEach(el => {
        el.classList.remove('instructor-conflict', 'instructor-warning');
      });
      
      // Check all instructor assignments for conflicts
      const conflictMap = new Map();
      
      for (let day = 1; day <= state.daysInMonth; day++) {
        for (let g = 0; g < state.groupsPerDay; g++) {
          state.cohorts.forEach((cohort, cohortIndex) => {
            const assignment = ensureGroup(day, cohort, g);
            if (assignment.instructor && assignment.instructor !== '' && assignment.instructor !== 'Clear') {
              const conflicts = findInstructorConflicts(assignment.instructor, day, cohort, g);
              if (conflicts.length > 0) {
                const key = `${day}-${cohortIndex}-${g}`;
                conflictMap.set(key, {
                  hasTimeConflict: conflicts.some(c => c.hasTimeConflict),
                  conflictCount: conflicts.length
                });
              }
            }
          });
        }
      }
      
      // Apply visual indicators to conflicted dropdowns
      const table = document.querySelector('#tableWrap table');
      if (table) {
        const rows = table.querySelectorAll('tbody tr');
        rows.forEach((row, rowIndex) => {
          const cells = row.querySelectorAll('td');
          cells.forEach((cell, cellIndex) => {
            if (cellIndex >= 2) { // Skip sticky columns
              const cohortIndex = cellIndex - 2;
              
              // Calculate day and group from row position
              const rowsPerGroup = 3; // site, faculty, schedule (no separators in 35HSN)
              const groupIndex = Math.floor(rowIndex / rowsPerGroup);
              const rowTypeIndex = rowIndex % rowsPerGroup;
              
              // Only check faculty rows (rowTypeIndex === 1)
              if (rowTypeIndex === 1) {
                const day = Math.floor(groupIndex / state.groupsPerDay) + 1;
                const groupInDay = groupIndex % state.groupsPerDay;
                
                if (day <= state.daysInMonth && cohortIndex < state.cohorts.length) {
                  const key = `${day}-${cohortIndex}-${groupInDay}`;
                  const conflict = conflictMap.get(key);
                  
                  if (conflict) {
                    const select = cell.querySelector('select');
                    if (select) {
                      if (conflict.hasTimeConflict) {
                        select.classList.add('instructor-conflict');
                        select.title = `Time conflict detected! This instructor has ${conflict.conflictCount} overlapping assignment(s).`;
                      } else {
                        select.classList.add('instructor-warning');
                        select.title = `Same day assignment detected. This instructor has ${conflict.conflictCount} other assignment(s) on this day.`;
                      }
                    }
                  }
                }
              }
            }
          });
        });
      }
    }

    function runConflictSummary() {
      const conflictSummary = {
        totalConflicts: 0,
        timeConflicts: 0,
        sameDayAssignments: 0,
        instructorsWithConflicts: new Set(),
        detailedConflicts: [] // New: detailed conflict information
      };
      
      for (let day = 1; day <= state.daysInMonth; day++) {
        for (let g = 0; g < state.groupsPerDay; g++) {
          state.cohorts.forEach(cohort => {
            const assignment = ensureGroup(day, cohort, g);
            if (assignment.instructor && assignment.instructor !== '' && assignment.instructor !== 'Clear') {
              const conflicts = findInstructorConflicts(assignment.instructor, day, cohort, g);
              if (conflicts.length > 0) {
                conflictSummary.totalConflicts += conflicts.length;
                conflictSummary.instructorsWithConflicts.add(assignment.instructor);
                
                conflicts.forEach(conflict => {
                  // Add detailed conflict information
                  conflictSummary.detailedConflicts.push({
                    instructor: assignment.instructor,
                    date: `${state.monthAbbrev} ${day}, ${state.year}`,
                    dayName: weekday(state.year, state.monthAbbrev, day),
                    primaryAssignment: {
                      cohort: cohort,
                      group: g + 1,
                      site: assignment.site,
                      schedule: assignment.schedule
                    },
                    conflictingAssignment: {
                      cohort: conflict.cohort,
                      group: conflict.group,
                      site: conflict.site,
                      schedule: conflict.schedule
                    },
                    hasTimeConflict: conflict.hasTimeConflict,
                    timeDetails: conflict.timeDetails
                  });
                  
                  if (conflict.hasTimeConflict) {
                    conflictSummary.timeConflicts++;
                  } else {
                    conflictSummary.sameDayAssignments++;
                  }
                });
              }
            }
          });
        }
      }
      
      return conflictSummary;
    }

    // Add conflict checking to the admin toolbar
    function showConflictReport() {
      const summary = runConflictSummary();
      
      let reportContent = '';
      
      if (summary.totalConflicts === 0) {
        reportContent = `
          <div style="text-align: center; padding: 2rem; color: #059669;">
            <div style="font-size: 3rem;">‚úÖ</div>
            <h4>No Conflicts Detected</h4>
            <p>Either there is no data or All instructor assignments are properly scheduled without conflicts.</p>
          </div>
        `;
      } else {
        // Group conflicts by instructor for better organization
        const conflictsByInstructor = {};
        summary.detailedConflicts.forEach(conflict => {
          if (!conflictsByInstructor[conflict.instructor]) {
            conflictsByInstructor[conflict.instructor] = [];
          }
          conflictsByInstructor[conflict.instructor].push(conflict);
        });
        
        reportContent = `
          <div style="margin: 1rem 0;">
            <h4>üìä Conflict Summary</h4>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
              <div style="padding: 1rem; background: #fef2f2; border-left: 4px solid #ef4444; border-radius: 0.5rem; cursor: pointer;" onclick="scrollToConflictTable('time-conflicts')">
                <div style="font-size: 1.5rem; font-weight: bold; color: #dc2626;">${summary.timeConflicts}</div>
                <div style="color: #7f1d1d;">Time Conflicts</div>
                <div style="font-size: 0.75rem; color: #7f1d1d; margin-top: 0.25rem;">Click to view details ‚Üì</div>
              </div>
              <div style="padding: 1rem; background: #fffbeb; border-left: 4px solid #f59e0b; border-radius: 0.5rem; cursor: pointer;" onclick="scrollToConflictTable('same-day-assignments')">
                <div style="font-size: 1.5rem; font-weight: bold; color: #d97706;">${summary.sameDayAssignments}</div>
                <div style="color: #92400e;">Same Day Assignments</div>
                <div style="font-size: 0.75rem; color: #92400e; margin-top: 0.25rem;">Click to view details ‚Üì</div>
              </div>
            </div>
            <div style="padding: 1rem; background: #f3f4f6; border-radius: 0.5rem;">
              <strong>Instructors with conflicts:</strong> ${summary.instructorsWithConflicts.size}<br>
              <strong>Total conflict instances:</strong> ${summary.totalConflicts}
            </div>
          </div>
          
          <div style="margin-top: 2rem;">
            <h4 style="margin-bottom: 1rem;">üìã Detailed Conflict Breakdown</h4>
            <div style="max-height: 400px; overflow-y: auto; border: 1px solid var(--border); border-radius: 0.5rem;">
              <table style="width: 100%; border-collapse: collapse; font-size: 0.875rem;">
                <thead style="background: var(--primary); color: white; position: sticky; top: 0;">
                  <tr>
                    <th style="padding: 0.75rem; text-align: left; border-right: 1px solid rgba(255,255,255,0.2);">Instructor</th>
                    <th style="padding: 0.75rem; text-align: left; border-right: 1px solid rgba(255,255,255,0.2);">Date</th>
                    <th style="padding: 0.75rem; text-align: left; border-right: 1px solid rgba(255,255,255,0.2);">Conflict Type</th>
                    <th style="padding: 0.75rem; text-align: left; border-right: 1px solid rgba(255,255,255,0.2);">Assignment 1</th>
                    <th style="padding: 0.75rem; text-align: left;">Assignment 2</th>
                  </tr>
                </thead>
                <tbody>
                  ${Object.keys(conflictsByInstructor).map(instructorName => {
                    return conflictsByInstructor[instructorName].map((conflict, index) => {
                      const isFirstRow = index === 0;
                      const isTimeConflict = conflict.hasTimeConflict;
                      const rowClass = isTimeConflict ? 'time-conflicts' : 'same-day-assignments';
                      const bgColor = isTimeConflict ? '#fef2f2' : '#fffbeb';
                      const borderColor = isTimeConflict ? '#ef4444' : '#f59e0b';
                      
                      return `
                        <tr class="${rowClass}" style="background: ${bgColor}; border-left: 3px solid ${borderColor};">
                          <td style="padding: 0.75rem; border-bottom: 1px solid #e5e7eb; font-weight: ${isFirstRow ? 'bold' : 'normal'};">
                            ${isFirstRow ? instructorName : ''}
                          </td>
                          <td style="padding: 0.75rem; border-bottom: 1px solid #e5e7eb;">
                            <div>${conflict.date}</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">${conflict.dayName}</div>
                          </td>
                          <td style="padding: 0.75rem; border-bottom: 1px solid #e5e7eb;">
                            <span style="padding: 0.25rem 0.5rem; border-radius: 1rem; font-size: 0.75rem; font-weight: bold; color: white; background: ${borderColor};">
                              ${isTimeConflict ? 'üö´ Time Conflict' : '‚ö†Ô∏è Same Day'}
                            </span>
                            ${conflict.timeDetails.current && conflict.timeDetails.conflict ? `
                              <div style="font-size: 0.75rem; margin-top: 0.25rem; color: var(--text-muted);">
                                ${getTimeString(conflict.timeDetails.current.start)}-${getTimeString(conflict.timeDetails.current.end)} vs 
                                ${getTimeString(conflict.timeDetails.conflict.start)}-${getTimeString(conflict.timeDetails.conflict.end)}
                              </div>
                            ` : ''}
                          </td>
                          <td style="padding: 0.75rem; border-bottom: 1px solid #e5e7eb;">
                            <div style="font-weight: bold;">${conflict.primaryAssignment.cohort} (Group ${conflict.primaryAssignment.group})</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">Site: ${conflict.primaryAssignment.site}</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">Time: ${conflict.primaryAssignment.schedule}</div>
                          </td>
                          <td style="padding: 0.75rem; border-bottom: 1px solid #e5e7eb;">
                            <div style="font-weight: bold;">${conflict.conflictingAssignment.cohort} (Group ${conflict.conflictingAssignment.group})</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">Site: ${conflict.conflictingAssignment.site}</div>
                            <div style="font-size: 0.75rem; color: var(--text-muted);">Time: ${conflict.conflictingAssignment.schedule}</div>
                          </td>
                        </tr>
                      `;
                    }).join('');
                  }).join('')}
                </tbody>
              </table>
            </div>
          </div>
        `;
      }
      
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.style.display = 'block';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 95%; width: 1200px; max-height: 90vh; overflow-y: auto;">
          <div class="modal-header">
            <h3 class="modal-title">Faculty Conflict Report</h3>
            <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">&times;</button>
          </div>
          <div class="modal-body">
            ${reportContent}
            <div class="btn-group" style="justify-content: space-between; margin-top: 1.5rem; flex-wrap: wrap; gap: 0.5rem;">
              <div>
                <button onclick="exportConflictReport()" class="btn btn-info">üìã Export Report</button>
                <button onclick="updateConflictIndicators(); showToast('Conflict indicators updated', 'info');" class="btn btn-primary">üîÑ Refresh Indicators</button>
              </div>
              <button onclick="this.closest('.modal').remove()" class="btn btn-secondary">Close</button>
            </div>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Add scroll function
      window.scrollToConflictTable = (section) => {
        const rows = modal.querySelectorAll(`.${section}`);
        if (rows.length > 0) {
          rows[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Highlight the rows briefly
          rows.forEach(row => {
            row.style.transform = 'scale(1.02)';
            row.style.transition = 'transform 0.3s ease';
            setTimeout(() => {
              row.style.transform = 'scale(1)';
            }, 300);
          });
        }
      };
      
      document.body.appendChild(modal);
    }

    function exportConflictReport() {
      const summary = runConflictSummary();
      
      if (summary.totalConflicts === 0) {
        showToast('No conflicts to export', 'info');
        return;
      }
      
      // Create CSV content
      let csvContent = 'Faculty Conflict Report\n';
      csvContent += `Generated on: ${new Date().toLocaleDateString()}\n`;
      csvContent += `Calendar: ${state.monthAbbrev} ${state.year}\n\n`;
      
      csvContent += 'SUMMARY\n';
      csvContent += `Time Conflicts,${summary.timeConflicts}\n`;
      csvContent += `Same Day Assignments,${summary.sameDayAssignments}\n`;
      csvContent += `Instructors with Conflicts,${summary.instructorsWithConflicts.size}\n`;
      csvContent += `Total Conflict Instances,${summary.totalConflicts}\n\n`;
      
      csvContent += 'DETAILED CONFLICTS\n';
      csvContent += 'Instructor,Date,Day,Conflict Type,Assignment 1 - Cohort,Assignment 1 - Group,Assignment 1 - Site,Assignment 1 - Schedule,Assignment 2 - Cohort,Assignment 2 - Group,Assignment 2 - Site,Assignment 2 - Schedule\n';
      
      summary.detailedConflicts.forEach(conflict => {
        const conflictType = conflict.hasTimeConflict ? 'Time Conflict' : 'Same Day Assignment';
        csvContent += `"${conflict.instructor}","${conflict.date}","${conflict.dayName}","${conflictType}",`;
        csvContent += `"${conflict.primaryAssignment.cohort}","${conflict.primaryAssignment.group}","${conflict.primaryAssignment.site}","${conflict.primaryAssignment.schedule}",`;
        csvContent += `"${conflict.conflictingAssignment.cohort}","${conflict.conflictingAssignment.group}","${conflict.conflictingAssignment.site}","${conflict.conflictingAssignment.schedule}"\n`;
      });
      
      // Download CSV
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const link = document.createElement('a');
      const url = URL.createObjectURL(blob);
      link.setAttribute('href', url);
      link.setAttribute('download', `Faculty_Conflict_Report_${state.monthAbbrev}_${state.year}.csv`);
      link.style.visibility = 'hidden';
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      
      showToast('Conflict report exported successfully', 'success');
    }

    // ANALYTICS FUNCTIONS
    let analyticsChart = null;

    // Parse hours from schedule string (handles formats like "0700-1530", "8h", "3h;5h")
    function parseHours(schedule) {
      if (!schedule || schedule.trim() === '') return 0;
      
      schedule = schedule.trim();
      
      // Handle "Xh" format
      const hourMatch = schedule.match(/^(\d+(?:\.\d+)?)h$/);
      if (hourMatch) {
        return parseFloat(hourMatch[1]);
      }
      
      // Handle "Xh;Yh" format (sum them)
      const multiHourMatch = schedule.match(/^(\d+(?:\.\d+)?)h;(\d+(?:\.\d+)?)h$/);
      if (multiHourMatch) {
        return parseFloat(multiHourMatch[1]) + parseFloat(multiHourMatch[2]);
      }
      
      // Handle time range format "HHMM-HHMM"
      const timeMatch = schedule.match(/^(\d{4})-(\d{4})$/);
      if (timeMatch) {
        const startTime = timeMatch[1];
        const endTime = timeMatch[2];
        
        const startHour = parseInt(startTime.substring(0, 2));
        const startMin = parseInt(startTime.substring(2, 4));
        const endHour = parseInt(endTime.substring(0, 2));
        const endMin = parseInt(endTime.substring(2, 4));
        
        let totalMinutes = (endHour * 60 + endMin) - (startHour * 60 + startMin);
        
        // Handle overnight shifts
        if (totalMinutes < 0) {
          totalMinutes += 24 * 60;
        }
        
        return totalMinutes / 60;
      }
      
      return 0;
    }

    // Get all faculty members from current data
    function getAllFacultyMembers() {
      const facultySet = new Set();
      
      for (let day = 1; day <= state.daysInMonth; day++) {
        if (state.data[day]) {
          state.cohorts.forEach(cohort => {
            if (state.data[day][cohort]) {
              state.data[day][cohort].forEach(group => {
                if (group.instructor && group.instructor.trim() !== '') {
                  facultySet.add(group.instructor.trim());
                }
              });
            }
          });
        }
      }
      
      return Array.from(facultySet).sort();
    }

    // Calculate analytics data
    function calculateAnalytics(timePeriod, facultyFilter, specificFaculty, deductLunch) {
      const results = {
        facultyData: {},
        totalHours: 0,
        totalDays: 0,
        averageHoursPerDay: 0,
        workingDays: []
      };

      const lunchDeduction = deductLunch ? 0.5 : 0;
      
      // Determine date range based on time period
      let startDay = 1;
      let endDay = state.daysInMonth;
      
      if (timePeriod === 'week') {
        endDay = Math.min(7, state.daysInMonth);
      } else if (timePeriod === '2weeks') {
        endDay = Math.min(14, state.daysInMonth);
      }

      // Process each day in the range
      for (let day = startDay; day <= endDay; day++) {
        let dayHasWork = false;
        
        if (state.data[day]) {
          state.cohorts.forEach(cohort => {
            if (state.data[day][cohort]) {
              state.data[day][cohort].forEach(group => {
                if (group.instructor && group.instructor.trim() !== '' && group.schedule) {
                  const instructor = group.instructor.trim();
                  const hours = parseHours(group.schedule);
                  
                  if (hours > 0) {
                    // Apply faculty filter
                    if (facultyFilter === 'all' || 
                        (facultyFilter === 'individual' && instructor === specificFaculty)) {
                      
                      if (!results.facultyData[instructor]) {
                        results.facultyData[instructor] = {
                          totalHours: 0,
                          workingDays: 0,
                          dailyHours: {},
                          assignments: []
                        };
                      }
                      
                      const adjustedHours = Math.max(0, hours - lunchDeduction);
                      results.facultyData[instructor].totalHours += adjustedHours;
                      results.facultyData[instructor].dailyHours[day] = 
                        (results.facultyData[instructor].dailyHours[day] || 0) + adjustedHours;
                      
                      results.facultyData[instructor].assignments.push({
                        day: day,
                        cohort: cohort,
                        site: group.site || 'N/A',
                        schedule: group.schedule,
                        hours: adjustedHours
                      });
                      
                      dayHasWork = true;
                    }
                  }
                }
              });
            }
          });
        }
        
        if (dayHasWork) {
          results.workingDays.push(day);
        }
      }

      // Calculate summary statistics
      Object.keys(results.facultyData).forEach(instructor => {
        const data = results.facultyData[instructor];
        data.workingDays = Object.keys(data.dailyHours).length;
        data.averageHoursPerDay = data.workingDays > 0 ? data.totalHours / data.workingDays : 0;
        results.totalHours += data.totalHours;
      });

      results.totalDays = results.workingDays.length;
      results.averageHoursPerDay = results.totalDays > 0 ? results.totalHours / results.totalDays : 0;
      
      return results;
    }

    // Generate chart based on type and data
    function generateChart(chartType, analyticsData, analysisType) {
      const ctx = document.getElementById('dataChart').getContext('2d');
      
      // Destroy existing chart
      if (analyticsChart) {
        analyticsChart.destroy();
      }

      const facultyNames = Object.keys(analyticsData.facultyData);
      
      let chartData, chartOptions;

      if (chartType === 'bar') {
        if (analysisType === 'hours') {
          chartData = {
            labels: facultyNames,
            datasets: [{
              label: 'Total Hours',
              data: facultyNames.map(name => analyticsData.facultyData[name].totalHours),
              backgroundColor: 'rgba(59, 130, 246, 0.8)',
              borderColor: 'rgba(59, 130, 246, 1)',
              borderWidth: 1
            }]
          };
        } else if (analysisType === 'comparative') {
          chartData = {
            labels: facultyNames,
            datasets: [
              {
                label: 'Total Hours',
                data: facultyNames.map(name => analyticsData.facultyData[name].totalHours),
                backgroundColor: 'rgba(59, 130, 246, 0.8)',
                borderColor: 'rgba(59, 130, 246, 1)',
                borderWidth: 1
              },
              {
                label: 'Working Days',
                data: facultyNames.map(name => analyticsData.facultyData[name].workingDays),
                backgroundColor: 'rgba(16, 185, 129, 0.8)',
                borderColor: 'rgba(16, 185, 129, 1)',
                borderWidth: 1
              }
            ]
          };
        }
        
        chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: analysisType === 'comparative' ? 'Hours / Days' : 'Hours'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Faculty Members'
              }
            }
          }
        };
        
        analyticsChart = new Chart(ctx, {
          type: 'bar',
          data: chartData,
          options: chartOptions
        });
      } 
      else if (chartType === 'line') {
        // Professional colored bar graph showing data with appropriate labels
        const datasets = [];
        
        if (analysisType === 'trends') {
          const days = Array.from({length: state.daysInMonth}, (_, i) => i + 1);
          facultyNames.forEach((name, index) => {
            const professionalColors = [
              'rgba(59, 130, 246, 0.8)',   // Professional Blue
              'rgba(16, 185, 129, 0.8)',   // Professional Green  
              'rgba(245, 158, 11, 0.8)',   // Professional Amber
              'rgba(239, 68, 68, 0.8)',    // Professional Red
              'rgba(139, 92, 246, 0.8)',   // Professional Purple
              'rgba(6, 182, 212, 0.8)',    // Professional Cyan
              'rgba(236, 72, 153, 0.8)',   // Professional Pink
              'rgba(34, 197, 94, 0.8)',    // Professional Emerald
              'rgba(251, 146, 60, 0.8)',   // Professional Orange
              'rgba(168, 85, 247, 0.8)'    // Professional Violet
            ];
            
            const borderColors = [
              'rgba(59, 130, 246, 1)',
              'rgba(16, 185, 129, 1)', 
              'rgba(245, 158, 11, 1)',
              'rgba(239, 68, 68, 1)',
              'rgba(139, 92, 246, 1)',
              'rgba(6, 182, 212, 1)',
              'rgba(236, 72, 153, 1)',
              'rgba(34, 197, 94, 1)',
              'rgba(251, 146, 60, 1)',
              'rgba(168, 85, 247, 1)'
            ];
            
            datasets.push({
              label: name,
              data: days.map(day => analyticsData.facultyData[name]?.dailyHours[day] || 0),
              backgroundColor: professionalColors[index % professionalColors.length],
              borderColor: borderColors[index % borderColors.length],
              borderWidth: 2,
              borderRadius: 4,
              borderSkipped: false
            });
          });
          
          chartData = {
            labels: days.map(day => `Day ${day}`),
            datasets: datasets
          };
        } else {
          // For other analysis types, show faculty totals as colored bars
          const professionalColors = [
            'rgba(59, 130, 246, 0.8)',   // Professional Blue
            'rgba(16, 185, 129, 0.8)',   // Professional Green  
            'rgba(245, 158, 11, 0.8)',   // Professional Amber
            'rgba(239, 68, 68, 0.8)',    // Professional Red
            'rgba(139, 92, 246, 0.8)',   // Professional Purple
            'rgba(6, 182, 212, 0.8)',    // Professional Cyan
            'rgba(236, 72, 153, 0.8)',   // Professional Pink
            'rgba(34, 197, 94, 0.8)',    // Professional Emerald
            'rgba(251, 146, 60, 0.8)',   // Professional Orange
            'rgba(168, 85, 247, 0.8)'    // Professional Violet
          ];
          
          const borderColors = [
            'rgba(59, 130, 246, 1)',
            'rgba(16, 185, 129, 1)', 
            'rgba(245, 158, 11, 1)',
            'rgba(239, 68, 68, 1)',
            'rgba(139, 92, 246, 1)',
            'rgba(6, 182, 212, 1)',
            'rgba(236, 72, 153, 1)',
            'rgba(34, 197, 94, 1)',
            'rgba(251, 146, 60, 1)',
            'rgba(168, 85, 247, 1)'
          ];
          
          chartData = {
            labels: facultyNames,
            datasets: [{
              label: 'Total Hours',
              data: facultyNames.map(name => analyticsData.facultyData[name]?.totalHours || 0),
              backgroundColor: facultyNames.map((_, index) => professionalColors[index % professionalColors.length]),
              borderColor: facultyNames.map((_, index) => borderColors[index % borderColors.length]),
              borderWidth: 2,
              borderRadius: 6,
              borderSkipped: false
            }]
          };
        }
        
        chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                font: {
                  size: 12,
                  weight: 'bold'
                },
                color: '#374151',
                padding: 20
              }
            },
            title: {
              display: true,
              text: analysisType === 'trends' ? 'Faculty Hours Trends by Day' : 'Faculty Total Hours',
              font: {
                size: 16,
                weight: 'bold'
              },
              color: '#111827',
              padding: 20
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Hours',
                font: {
                  size: 14,
                  weight: 'bold'
                },
                color: '#374151'
              },
              grid: {
                color: 'rgba(0, 0, 0, 0.1)'
              },
              ticks: {
                font: {
                  size: 12
                },
                color: '#6B7280'
              }
            },
            x: {
              title: {
                display: true,
                text: analysisType === 'trends' ? 'Days' : 'Faculty Members',
                font: {
                  size: 14,
                  weight: 'bold'
                },
                color: '#374151'
              },
              grid: {
                color: 'rgba(0, 0, 0, 0.1)'
              },
              ticks: {
                font: {
                  size: 12
                },
                color: '#6B7280',
                maxRotation: 45
              }
            }
          }
        };
        
        analyticsChart = new Chart(ctx, {
          type: 'bar',
          data: chartData,
          options: chartOptions
        });
      }
      else if (chartType === 'pie') {
        const colors = [
          'rgba(59, 130, 246, 0.8)',
          'rgba(16, 185, 129, 0.8)',
          'rgba(245, 158, 11, 0.8)',
          'rgba(239, 68, 68, 0.8)',
          'rgba(139, 92, 246, 0.8)',
          'rgba(236, 72, 153, 0.8)',
          'rgba(20, 184, 166, 0.8)',
          'rgba(251, 146, 60, 0.8)',
          'rgba(34, 197, 94, 0.8)',
          'rgba(168, 85, 247, 0.8)',
          'rgba(244, 63, 94, 0.8)',
          'rgba(6, 182, 212, 0.8)'
        ];
        
        // Ensure we have enough colors for all faculty members
        const facultyColors = facultyNames.map((_, index) => colors[index % colors.length]);
        const borderColors = facultyColors.map(color => color.replace('0.8', '1'));
        
        chartData = {
          labels: facultyNames,
          datasets: [{
            data: facultyNames.map(name => analyticsData.facultyData[name].totalHours),
            backgroundColor: facultyColors,
            borderColor: borderColors,
            borderWidth: 2
          }]
        };
        
        chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'right',
              display: true,
              labels: {
                generateLabels: function(chart) {
                  const data = chart.data;
                  if (data.labels.length && data.datasets.length) {
                    return data.labels.map((label, i) => {
                      const value = data.datasets[0].data[i];
                      return {
                        text: `${label}: ${value.toFixed(1)}h`,
                        fillStyle: data.datasets[0].backgroundColor[i],
                        strokeStyle: data.datasets[0].borderColor[i],
                        lineWidth: data.datasets[0].borderWidth,
                        hidden: false,
                        index: i
                      };
                    });
                  }
                  return [];
                }
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const label = context.label || '';
                  const value = context.parsed;
                  return `${label}: ${value.toFixed(1)}h`;
                }
              }
            }
          }
        };
        
        analyticsChart = new Chart(ctx, {
          type: 'pie',
          data: chartData,
          options: chartOptions
        });
      }
      else if (chartType === 'histogram') {
        // Create histogram of hours worked
        const allHours = facultyNames.map(name => analyticsData.facultyData[name].totalHours);
        const min = Math.min(...allHours);
        const max = Math.max(...allHours);
        const binCount = Math.min(10, facultyNames.length);
        const binSize = (max - min) / binCount;
        
        const bins = [];
        const binLabels = [];
        
        for (let i = 0; i < binCount; i++) {
          const binStart = min + (i * binSize);
          const binEnd = min + ((i + 1) * binSize);
          bins.push(0);
          binLabels.push(`${binStart.toFixed(1)}-${binEnd.toFixed(1)}h`);
        }
        
        allHours.forEach(hours => {
          const binIndex = Math.min(Math.floor((hours - min) / binSize), binCount - 1);
          bins[binIndex]++;
        });
        
        chartData = {
          labels: binLabels,
          datasets: [{
            label: 'Faculty Count',
            data: bins,
            backgroundColor: 'rgba(59, 130, 246, 0.8)',
            borderColor: 'rgba(59, 130, 246, 1)',
            borderWidth: 1
          }]
        };
        
        chartOptions = {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Number of Faculty'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Hours Range'
              }
            }
          }
        };
        
        analyticsChart = new Chart(ctx, {
          type: 'bar',
          data: chartData,
          options: chartOptions
        });
      }
    }

    // Display analytics table and summary
    function displayAnalyticsTable(analyticsData, timePeriod) {
      const summaryDiv = document.getElementById('summaryStats');
      const tableHead = document.querySelector('#detailsTable thead');
      const tableBody = document.querySelector('#detailsTable tbody');
      
      // Summary statistics
      const facultyCount = Object.keys(analyticsData.facultyData).length;
      const avgHoursPerFaculty = facultyCount > 0 ? analyticsData.totalHours / facultyCount : 0;
      
      summaryDiv.innerHTML = `
        <div class="stat-item">
          <span>Total Faculty:</span>
          <strong>${facultyCount}</strong>
        </div>
        <div class="stat-item">
          <span>Total Hours:</span>
          <strong>${analyticsData.totalHours.toFixed(1)}h</strong>
        </div>
        <div class="stat-item">
          <span>Working Days:</span>
          <strong>${analyticsData.totalDays}</strong>
        </div>
        <div class="stat-item">
          <span>Avg Hours/Faculty:</span>
          <strong>${avgHoursPerFaculty.toFixed(1)}h</strong>
        </div>
        <div class="stat-item">
          <span>Avg Hours/Day:</span>
          <strong>${analyticsData.averageHoursPerDay.toFixed(1)}h</strong>
        </div>
      `;
      
      // Table headers
      tableHead.innerHTML = `
        <tr>
          <th>Faculty</th>
          <th>Total Hours</th>
          <th>Working Days</th>
          <th>Avg/Day</th>
        </tr>
      `;
      
      // Table body
      let tableRows = '';
      Object.keys(analyticsData.facultyData)
        .sort((a, b) => analyticsData.facultyData[b].totalHours - analyticsData.facultyData[a].totalHours)
        .forEach(faculty => {
          const data = analyticsData.facultyData[faculty];
          tableRows += `
            <tr>
              <td>${faculty}</td>
              <td>${data.totalHours.toFixed(1)}h</td>
              <td>${data.workingDays}</td>
              <td>${data.averageHoursPerDay.toFixed(1)}h</td>
            </tr>
          `;
        });
      
      tableBody.innerHTML = tableRows;
    }

    // Analytics Modal Functions
    function openAnalytics() {
      // Check if all fields are empty first
      if (isDataCompletelyEmpty()) {
        alert('Sorry this operation cannot be processed as all fields are empty. Please enter some data before generating analytics.');
        return;
      }
      
      document.getElementById('analyticsModal').style.display = 'block';
      
      // Populate faculty dropdown
      const facultyDropdown = document.getElementById('specificFaculty');
      const allFaculty = getAllFacultyMembers();
      
      facultyDropdown.innerHTML = '<option value="">Select Faculty Member</option>';
      allFaculty.forEach(faculty => {
        const option = document.createElement('option');
        option.value = faculty;
        option.textContent = faculty;
        facultyDropdown.appendChild(option);
      });
    }

    function closeAnalytics() {
      document.getElementById('analyticsModal').style.display = 'none';
      if (analyticsChart) {
        analyticsChart.destroy();
        analyticsChart = null;
      }
    }

    function generateAnalytics() {
      try {
        // Check if all fields are empty first
        if (isDataCompletelyEmpty()) {
          alert('Sorry this operation cannot be processed as all fields are empty. Please enter some data before generating analytics.');
          return;
        }
        
        // Validate data before generating analytics
        const incompleteGroups = validateDataForExport();
        
        if (incompleteGroups.length > 0) {
          // Highlight incomplete fields in the table
          highlightIncompleteFields();
          
          let errorMessage = 'Cannot generate analytics: Please complete the following missing data:\n\n';
          
          incompleteGroups.forEach((group, index) => {
            errorMessage += `${index + 1}. Day ${group.day} - Cohort: "${group.cohort}"\n`;
            errorMessage += `   Missing: ${group.missingFields.join(', ')}\n`;
            errorMessage += `   Row References: ${group.itemNumbers.join(', ')}\n\n`;
          });
          
          errorMessage += 'Red highlighted fields in the table show exactly which fields need to be completed.\n\nIncomplete data will result in inaccurate analytics.';
          alert(errorMessage);
          return;
        }
        
        // Clear any existing highlighting if validation passes
        clearHighlighting();
      } catch (error) {
        console.error('Analytics validation error:', error);
        alert('Error during validation. Please check the console for details.');
        return;
      }
      
      const timePeriod = document.getElementById('timePeriod').value;
      const facultySelect = document.getElementById('facultySelect').value;
      const specificFaculty = document.getElementById('specificFaculty').value;
      const chartType = document.getElementById('chartType').value;
      const analysisType = document.getElementById('analysisType').value;
      const deductLunch = document.getElementById('deductLunch').checked;
      
      if (facultySelect === 'individual' && !specificFaculty) {
        showToast('Please select a specific faculty member for individual analysis', 'warning');
        return;
      }
      
      const analyticsData = calculateAnalytics(timePeriod, facultySelect, specificFaculty, deductLunch);
      
      if (Object.keys(analyticsData.facultyData).length === 0) {
        showToast('No data found for the selected criteria', 'warning');
        return;
      }
      
      generateChart(chartType, analyticsData, analysisType);
      displayAnalyticsTable(analyticsData, timePeriod);
      
      showToast('Analytics generated successfully', 'success');
    }

    // Function to refresh analytics when lunch break checkbox changes
    function refreshAnalyticsOnLunchChange() {
      // Only refresh if analytics have already been generated (chart exists)
      if (analyticsChart) {
        try {
          // Get current settings
          const timePeriod = document.getElementById('timePeriod').value;
          const facultySelect = document.getElementById('facultySelect').value;
          const specificFaculty = document.getElementById('specificFaculty').value;
          const chartType = document.getElementById('chartType').value;
          const analysisType = document.getElementById('analysisType').value;
          const deductLunch = document.getElementById('deductLunch').checked;
          
          // Recalculate and update
          const analyticsData = calculateAnalytics(timePeriod, facultySelect, specificFaculty, deductLunch);
          
          if (Object.keys(analyticsData.facultyData).length > 0) {
            generateChart(chartType, analyticsData, analysisType);
            displayAnalyticsTable(analyticsData, timePeriod);
          }
        } catch (error) {
          console.error('Error refreshing analytics:', error);
        }
      }
    }

    function exportAnalytics() {
      if (!analyticsChart) {
        showToast('Please generate analytics first', 'warning');
        return;
      }
      
      const link = document.createElement('a');
      link.download = `analytics_${state.monthAbbrev}_${state.year}.png`;
      link.href = analyticsChart.toBase64Image();
      link.click();
      
      showToast('Chart exported successfully', 'success');
    }

    function clearAnalytics() {
      if (analyticsChart) {
        analyticsChart.destroy();
        analyticsChart = null;
      }
      
      document.getElementById('summaryStats').innerHTML = '';
      document.querySelector('#detailsTable thead').innerHTML = '';
      document.querySelector('#detailsTable tbody').innerHTML = '';
      
      showToast('Analytics cleared', 'info');
    }

    // Export Data Summary to Professional PDF
    function exportSummaryToPdf() {
      try {
        // Check if summary data exists
        const summaryStats = document.getElementById('summaryStats');
        const detailsTable = document.getElementById('detailsTable');
        
        if (!summaryStats.innerHTML.trim() && !detailsTable.querySelector('tbody').innerHTML.trim()) {
          showToast('No analytics data to export. Please generate analytics first.', 'warning');
          return;
        }

        // Initialize jsPDF with letter size
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF({
          orientation: 'portrait',
          unit: 'mm',
          format: 'letter' // 8.5 x 11 inches
        });

        // Professional header
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        
        // Header styling
        doc.setFillColor(59, 130, 246); // Primary blue color
        doc.rect(0, 0, pageWidth, 25, 'F');
        
        // Title
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(18);
        doc.setFont('helvetica', 'bold');
        doc.text('Nursing Calendar Scheduler', 15, 12);
        doc.setFontSize(12);
        doc.text('Data Analytics Summary Report', 15, 19);
        
        // Date and time
        const now = new Date();
        const dateString = now.toLocaleDateString('en-US', { 
          year: 'numeric', 
          month: 'long', 
          day: 'numeric' 
        });
        const timeString = now.toLocaleTimeString('en-US', { 
          hour: '2-digit', 
          minute: '2-digit' 
        });
        
        doc.setTextColor(0, 0, 0);
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.text(`Generated: ${dateString} at ${timeString}`, pageWidth - 15, 35, { align: 'right' });
        
        let yPosition = 45;
        
        // Summary Statistics Section
        const summaryStatsElement = document.getElementById('summaryStats');
        if (summaryStatsElement && summaryStatsElement.innerHTML.trim()) {
          doc.setFontSize(14);
          doc.setFont('helvetica', 'bold');
          doc.setTextColor(59, 130, 246);
          doc.text('Summary Statistics', 15, yPosition);
          yPosition += 10;
          
          // Draw section separator line
          doc.setDrawColor(59, 130, 246);
          doc.setLineWidth(0.5);
          doc.line(15, yPosition, pageWidth - 15, yPosition);
          yPosition += 8;
          
          // Extract and format summary stats in a table format
          const statItems = summaryStatsElement.querySelectorAll('.stat-item');
          
          if (statItems.length > 0) {
            // Create summary statistics table
            const statsTableWidth = pageWidth - 30;
            const itemNumWidth = 15;
            const descriptionWidth = statsTableWidth * 0.65;
            const valueWidth = statsTableWidth * 0.35 - itemNumWidth;
            
            // Table header for summary stats
            doc.setFillColor(239, 246, 255);
            doc.rect(15, yPosition - 5, statsTableWidth, 8, 'F');
            
            doc.setFontSize(10);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(0, 0, 0);
            doc.text('#', 17, yPosition);
            doc.text('Description', 32, yPosition);
            doc.text('Value', 15 + itemNumWidth + descriptionWidth + 5, yPosition);
            
            yPosition += 10;
            
            // Table rows for summary stats
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(10);
            
            statItems.forEach((item, index) => {
              const statText = item.textContent.trim();
              if (statText) {
                // Parse the stat text to separate description and value
                const parts = statText.split(':');
                const description = parts[0] ? parts[0].trim() : statText;
                const value = parts[1] ? parts[1].trim() : '';
                
                // Alternate row background
                if (index % 2 === 0) {
                  doc.setFillColor(248, 250, 252);
                  doc.rect(15, yPosition - 4, statsTableWidth, 6, 'F');
                }
                
                // Item number
                doc.text((index + 1).toString(), 17, yPosition);
                
                // Description (truncate if too long)
                const maxDescLength = 45;
                const truncatedDesc = description.length > maxDescLength ? 
                  description.substring(0, maxDescLength - 3) + '...' : description;
                doc.text(truncatedDesc, 32, yPosition);
                
                // Value (right-aligned in its column)
                if (value) {
                  doc.text(value, 15 + itemNumWidth + descriptionWidth + 5, yPosition);
                }
                
                yPosition += 6;
              }
            });
            
            yPosition += 8;
          }
        }
        
        // Details Table Section with Multi-Page Support
        const detailsTableElement = document.getElementById('detailsTable');
        const tableBody = detailsTableElement.querySelector('tbody');
        const tableHead = detailsTableElement.querySelector('thead');
        
        if (tableBody && tableBody.innerHTML.trim() && tableHead && tableHead.innerHTML.trim()) {
          // Table headers with Item # column
          const originalHeaders = Array.from(tableHead.querySelectorAll('th')).map(th => th.textContent.trim());
          const headers = ['#', ...originalHeaders]; // Add Item # column
          const rows = Array.from(tableBody.querySelectorAll('tr')).map((tr, index) => [
            (index + 1).toString(), // Add row number
            ...Array.from(tr.querySelectorAll('td')).map(td => td.textContent.trim())
          ]);
          
          // Optimize column widths for better fit
          const availableWidth = pageWidth - 30;
          const itemColWidth = 12; // Fixed width for item number
          const remainingWidth = availableWidth - itemColWidth;
          const otherColWidth = remainingWidth / (headers.length - 1);
          
          // Pagination settings
          const maxRowsFirstPage = 20; // Max 20 faculty members on first page
          const maxRowsPerPage = 35; // More rows on subsequent pages (no summary stats)
          const rowHeight = 5.5;
          const headerHeight = 12;
          
          let currentRowIndex = 0;
          let pageNumber = 1;
          let isFirstPage = true;
          
          while (currentRowIndex < rows.length) {
            // Determine how many rows for this page
            const rowsThisPage = isFirstPage ? 
              Math.min(maxRowsFirstPage, rows.length - currentRowIndex) :
              Math.min(maxRowsPerPage, rows.length - currentRowIndex);
            
            const pageRows = rows.slice(currentRowIndex, currentRowIndex + rowsThisPage);
            
            // Check remaining space on current page for first page
            if (isFirstPage) {
              const remainingSpace = pageHeight - yPosition - 25;
              const neededSpace = headerHeight + (rowsThisPage * rowHeight) + 10;
              
              // If not enough space on first page, start table on new page
              if (neededSpace > remainingSpace && yPosition > 60) {
                doc.addPage();
                yPosition = 25;
                isFirstPage = false;
              }
            }
            
            // Add new page for continuation (except first page)
            if (!isFirstPage && currentRowIndex > 0) {
              doc.addPage();
              yPosition = 25;
            }
            
            // Section header
            doc.setFontSize(14);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(59, 130, 246);
            const sectionTitle = pageNumber === 1 ? 'Detailed Analysis' : `Detailed Analysis (Continued - Page ${pageNumber})`;
            doc.text(sectionTitle, 15, yPosition);
            yPosition += 8;
            
            // Draw section separator line
            doc.setDrawColor(59, 130, 246);
            doc.setLineWidth(0.5);
            doc.line(15, yPosition, pageWidth - 15, yPosition);
            yPosition += 6;
            
            // Draw table header
            doc.setFillColor(239, 246, 255);
            doc.rect(15, yPosition - 4, availableWidth, 7, 'F');
            
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(0, 0, 0);
            
            // Item # column header
            doc.text('#', 17, yPosition);
            
            // Other column headers
            headers.slice(1).forEach((header, index) => {
              const xPos = 15 + itemColWidth + (index * otherColWidth) + 2;
              const maxHeaderLength = 12;
              const truncatedHeader = header.length > maxHeaderLength ? 
                header.substring(0, maxHeaderLength - 2) + '..' : header;
              doc.text(truncatedHeader, xPos, yPosition);
            });
            
            yPosition += 8;
            
            // Draw table rows for this page
            doc.setFont('helvetica', 'normal');
            doc.setFontSize(8);
            
            pageRows.forEach((row, rowIndex) => {
              // Alternate row background
              if (rowIndex % 2 === 0) {
                doc.setFillColor(248, 250, 252);
                doc.rect(15, yPosition - 3, availableWidth, 5, 'F');
              }
              
              // Item number column
              doc.text(row[0], 17, yPosition);
              
              // Other columns
              row.slice(1).forEach((cell, cellIndex) => {
                const xPos = 15 + itemColWidth + (cellIndex * otherColWidth) + 2;
                const maxCellLength = 15;
                const cellText = cell.length > maxCellLength ? 
                  cell.substring(0, maxCellLength - 2) + '..' : cell;
                doc.text(cellText, xPos, yPosition);
              });
              
              yPosition += rowHeight;
            });
            
            // Add page summary at bottom of each page
            yPosition += 5;
            doc.setFontSize(8);
            doc.setTextColor(100, 100, 100);
            const startEntry = currentRowIndex + 1;
            const endEntry = currentRowIndex + rowsThisPage;
            doc.text(`Showing entries ${startEntry}-${endEntry} of ${rows.length} total faculty members`, 15, yPosition);
            
            // Update for next iteration
            currentRowIndex += rowsThisPage;
            pageNumber++;
            isFirstPage = false;
            yPosition = 25; // Reset for next page
          }
        }
        
        // Add footers to all pages
        const totalPages = doc.internal.getNumberOfPages();
        for (let i = 1; i <= totalPages; i++) {
          doc.setPage(i);
          const footerY = pageHeight - 15;
          doc.setFontSize(8);
          doc.setTextColor(128, 128, 128);
          doc.text('Nursing Calendar Scheduler - Professional Analytics Report', 15, footerY);
          doc.text(`Page ${i} of ${totalPages}`, pageWidth - 15, footerY, { align: 'right' });
        }
        
        // Generate filename with date
        const filename = `Analytics_Summary_${state.monthAbbrev || 'CAL'}_${state.year}_${now.getFullYear()}${(now.getMonth()+1).toString().padStart(2,'0')}${now.getDate().toString().padStart(2,'0')}.pdf`;
        
        // Save the PDF
        doc.save(filename);
        
        showToast('Analytics summary exported to PDF successfully', 'success');
        
      } catch (error) {
        console.error('PDF export error:', error);
        showToast('Error exporting PDF. Please try again.', 'error');
      }
    }

    // Analytics Event Listeners
    document.getElementById('dataAnalyticsBtn').addEventListener('click', openAnalytics);
    document.getElementById('closeAnalytics').addEventListener('click', closeAnalytics);
    document.getElementById('generateAnalytics').addEventListener('click', generateAnalytics);
    document.getElementById('exportAnalytics').addEventListener('click', exportAnalytics);
    document.getElementById('exportSummaryPdf').addEventListener('click', exportSummaryToPdf);
    document.getElementById('clearAnalytics').addEventListener('click', clearAnalytics);
    
    // Lunch break checkbox - refresh analytics instantly when changed
    document.getElementById('deductLunch').addEventListener('change', refreshAnalyticsOnLunchChange);

    // Conflict Report Event Listeners
    document.getElementById('conflictReportBtn').addEventListener('click', showConflictReport);
    document.getElementById('conflictSettingsBtn').addEventListener('click', showConflictSettings);

    // Global helper functions for conflict system
    window.suggestAlternative = (instructor, conflicts) => {
      suggestAlternativeInstructor(instructor, JSON.parse(conflicts.replace(/&quot;/g, '"')));
    };
    
    window.showDetailedConflicts = (instructor) => {
      showInstructorConflictDetails(instructor);
    };

    // Faculty selection toggle
    document.getElementById('facultySelect').addEventListener('change', function() {
      const specificFacultySelect = document.getElementById('specificFaculty');
      specificFacultySelect.disabled = this.value !== 'individual';
    });
  </script>

  <!-- Professional ExcelJS Export Implementation -->
  <script>
  (function(){
    if (window.__professionalExcelExport) return; 
    window.__professionalExcelExport = true;

    function getTable(){ 
      var w = document.getElementById('tableWrap'); 
      return w ? w.querySelector('table') : null; 
    }
    
    function headerTexts(tbl){ 
      return Array.from(tbl.querySelectorAll('thead th')).map(function(th){ 
        return (th.textContent || '').trim(); 
      }); 
    }
    
    function rowToArray(tr){
      return Array.from(tr.children).map(function(td){
        var sel = td.querySelector && td.querySelector('select');
        if (sel) return sel.value || '';
        var input = td.querySelector && td.querySelector('input');
        if (input) return input.value || '';
        return (td.textContent || '').trim();
      });
    }
    
    function buildAOAFromDOM(){
      var tbl = getTable(); 
      if(!tbl){ 
        showToast('Export failed: calendar table not found', 'error'); 
        return null; 
      }
      var aoa = [];
      aoa.push(headerTexts(tbl));
      Array.from(tbl.querySelectorAll('tbody tr')).forEach(function(tr){ 
        aoa.push(rowToArray(tr)); 
      });
      return aoa;
    }
    
    function fullMonthName(abbr){
      var map = {
        JAN:'January', FEB:'February', MAR:'March', APR:'April', 
        MAY:'May', JUN:'June', JUL:'July', AUG:'August', 
        SEP:'September', OCT:'October', NOV:'November', DEC:'December'
      };
      abbr = (abbr || '').toUpperCase().slice(0,3);
      return map[abbr] || abbr;
    }

    function ensureExcelJS(cb){
      if (window.ExcelJS) return cb();
      var s = document.createElement('script');
      s.onload = cb;
      s.src = 'https://cdn.jsdelivr.net/npm/exceljs@4.3.0/dist/exceljs.min.js';
      document.head.appendChild(s);
    }

    function downloadBlob(data, filename, mime){
      var blob = new Blob([data], {type: mime || 'application/octet-stream'});
      var a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){ 
        URL.revokeObjectURL(a.href); 
        a.remove(); 
      }, 400);
    }

    function professionalExcelExport(){
      try {
        // Check if all fields are empty first
        if (isDataCompletelyEmpty()) {
          alert('Sorry this operation cannot be processed as all fields are empty. Please enter some data before exporting.');
          return;
        }
        
        // Validate data before export
        const incompleteGroups = validateDataForExport();
        
        if (incompleteGroups.length > 0) {
          // Highlight incomplete fields in the table
          highlightIncompleteFields();
          
          let errorMessage = 'Cannot export XLSX: Please complete the following missing data:\n\n';
          
          incompleteGroups.forEach((group, index) => {
            errorMessage += `${index + 1}. Day ${group.day} - Cohort: "${group.cohort}"\n`;
            errorMessage += `   Missing: ${group.missingFields.join(', ')}\n`;
            errorMessage += `   Row References: ${group.itemNumbers.join(', ')}\n\n`;
          });
          
          errorMessage += 'Red highlighted fields in the table show exactly which fields need to be completed.';
          alert(errorMessage);
          return;
        }
        
        // Clear any existing highlighting if validation passes
        clearHighlighting();
      } catch (error) {
        console.error('Professional Excel export validation error:', error);
        alert('Error during validation. Please check the console for details.');
        return;
      }

      var aoa = buildAOAFromDOM(); 
      if(!aoa) return;
      
      ensureExcelJS(function(){
        try{
          var ExcelJS = window.ExcelJS;
          var abbr = (document.getElementById('monthAbbrev')?.value || state.monthAbbrev || '').toUpperCase().slice(0,3) || 'NOV';
          var year = (document.getElementById('yearInput')?.value || state.year || '2025');
          var titleText = 'Nursing Schedule for ' + fullMonthName(abbr) + ' ' + year;

          var wb = new ExcelJS.Workbook();
          var ws = wb.addWorksheet('Schedule', {
            properties: { 
              defaultRowHeight: 25,  // Increased default row height for readability
              printOptions: {
                fitToPage: true,
                fitToWidth: 1,
                fitToHeight: 0,  // Let height be flexible
                orientation: 'landscape',  // Set to landscape by default
                paperSize: 9,  // Letter size (11x8.5" in landscape)
                margins: { top: 0.5, bottom: 0.5, left: 0.3, right: 0.3, header: 0, footer: 0 }
              }
            },
            views: [{ state:'frozen', xSplit:2, ySplit:2 }],
            pageSetup: {
              paperSize: 9,  // Letter size
              orientation: 'landscape',
              fitToPage: true,
              fitToWidth: 1,
              fitToHeight: 0,
              margins: { 
                left: 0.3, right: 0.3, top: 0.5, bottom: 0.5, header: 0, footer: 0 
              }
            }
          });

          var totalCols = (aoa[0] && aoa[0].length) ? aoa[0].length : 1;

          // Title row with professional blue styling - BIGGER FONTS FOR PRINT
          ws.addRow([titleText]);
          ws.mergeCells(1, 1, 1, totalCols);
          for (var c=1; c<=totalCols; c++){
            var cell = ws.getCell(1, c);
            cell.font = { bold: true, size: 24, color: { argb: 'FFFFFFFF' } };  // Increased from 18 to 24
            cell.alignment = { horizontal: 'center', vertical: 'middle' };
            cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: '4472C4' } };
            cell.border = { 
              top: {style:'medium', color:{argb:'4472C4'}}, 
              left: {style:'medium', color:{argb:'4472C4'}}, 
              bottom: {style:'medium', color:{argb:'4472C4'}}, 
              right: {style:'medium', color:{argb:'4472C4'}} 
            };
          }
          ws.getRow(1).height = 40;  // Increased height for larger font

          // Header row with blue background - BIGGER FONTS FOR PRINT
          var header = aoa[0] || [];
          ws.addRow(header);
          for (var c=1; c<=totalCols; c++){
            var hcell = ws.getCell(2, c);
            hcell.font = { bold: true, size: 16, color: { argb: 'FFFFFFFF' } };  // Increased from 12 to 16
            hcell.alignment = { horizontal: 'center', vertical: 'middle', wrapText: true };
            hcell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: '4472C4' } };
            hcell.border = { 
              top: {style:'thin', color:{argb:'000000'}}, 
              left: {style:'thin', color:{argb:'000000'}}, 
              bottom: {style:'thin', color:{argb:'000000'}}, 
              right: {style:'thin', color:{argb:'000000'}} 
            };
          }
          ws.getRow(2).height = 30;  // Increased height for larger font

          // Body rows with professional styling
          for (var r=1; r<aoa.length; r++){
            ws.addRow(aoa[r]);
          }
          
          var bodyStart = 3;
          var bodyEnd = ws.rowCount;
          
          for (var r=bodyStart; r<=bodyEnd; r++){
            var bodyIndex = r - bodyStart;
            var isSeparatorRow = ((bodyIndex + 1) % 4 === 0);
            
            for (var c=1; c<=totalCols; c++){
              var cell = ws.getCell(r, c);
              
              if (c === 1) {
                // Item number column - smaller font, centered
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'F8F9FA' } };
                cell.font = { bold: true, size: 12, color: { argb: '666666' } };
              } else if (c === 2) {
                // Day header column - light blue background, BIGGER FONT
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'E8F4FD' } };
                cell.font = { bold: true, size: 14 };  // Increased from 11 to 14
              } else if (isSeparatorRow) {
                // Separator rows - light gray
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'F0F0F0' } };
                cell.font = { size: 12 };  // Consistent font size
              } else {
                // Regular data cells - white, BIGGER FONT FOR READABILITY
                cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFFFFF' } };
                cell.font = { size: 14 };  // Increased from 11 to 14
              }
              
              cell.border = { 
                top: {style:'thin', color:{argb:'D0D0D0'}}, 
                left: {style:'thin', color:{argb:'D0D0D0'}}, 
                bottom: {style:'thin', color:{argb:'D0D0D0'}}, 
                right: {style:'thin', color:{argb:'D0D0D0'}} 
              };
              
              cell.alignment = { 
                horizontal: (c <= 2 ? 'center' : 'center'), 
                vertical: 'middle', 
                wrapText: true 
              };
            }
            
            // Set row height - INCREASED FOR PRINT READABILITY
            ws.getRow(r).height = isSeparatorRow ? 15 : 25;  // Increased heights
          }

          // Column widths optimized for MAXIMUM PAPER UTILIZATION IN LANDSCAPE
          var cols = [];
          var cohortCount = totalCols - 2;  // Total columns minus item# and date columns
          
          // Calculate optimal widths to fill landscape paper (approx 10.5 inches = 252 points)
          // Leave some margin space, so use about 240 points total width
          var availableWidth = 240;
          var itemColWidth = 6;      // Minimal width for item numbers
          var dateColWidth = 22;     // Fixed width for date column
          var remainingWidth = availableWidth - itemColWidth - dateColWidth;
          var cohortColWidth = Math.max(18, Math.floor(remainingWidth / cohortCount));
          
          for (var i=1; i<=totalCols; i++){
            var width;
            if (i === 1) {
              width = itemColWidth;    // ITEM # column - minimal
            } else if (i === 2) {
              width = dateColWidth;    // Month/Date column - fixed
            } else {
              width = cohortColWidth;  // Cohort columns - maximized to fill paper
            }
            cols.push({ width: width });
          }
          ws.columns = cols;
          
          // Additional print optimization settings
          ws.pageSetup.printArea = 'A1:' + String.fromCharCode(64 + totalCols) + ws.rowCount;
          ws.pageSetup.printTitlesRow = '1:2';  // Repeat title and header rows on each page

          // Generate and download
          wb.xlsx.writeBuffer().then(function(buf){
            var fname = 'Print_Ready_Schedule_' + abbr + '_' + year + '.xlsx';
            downloadBlob(buf, fname, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
            showToast('Print-Ready XLSX exported! ‚úÖ Landscape orientation ‚úÖ Large fonts ‚úÖ Optimized columns', 'success');
          }).catch(function(err){
            showToast('ExcelJS export error: ' + (err && err.message ? err.message : err), 'error');
          });

        }catch(e){
          showToast('Export error: ' + (e && e.message ? e.message : e), 'error');
        }
      });
    }

    function wire(){
      var xbtn = document.getElementById('exportXlsxBtn');
      if (xbtn && !xbtn.__professionalExcelStyled){
        xbtn.__professionalExcelStyled = true;
        // Intercept the export button click to use professional styling
        xbtn.addEventListener('click', function(ev){
          try{
            ev.preventDefault();
            ev.stopImmediatePropagation();
          }catch(e){}
          setTimeout(professionalExcelExport, 10);
          return false;
        }, true);
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', wire);
    } else { 
      wire(); 
    }
  })();

  // ==================== SECURITY PROTECTION SYSTEM ====================

  // Code Obfuscation - State Management
  const _0x4a7c = ['devtools', 'detect', 'resize', 'innerHeight', 'innerWidth', 'outerHeight', 'outerWidth', 'title', 'modification', 'protection'];
  
  // Developer Tools Detection
  (function() {
    let _0x1a2b = false;
    const _0x3c4d = () => {
      const _0x5e6f = window[_0x4a7c[4]] - window[_0x4a7c[3]];
      const _0x7g8h = window[_0x4a7c[6]] - window[_0x4a7c[5]];
      if (_0x5e6f > 200 || _0x7g8h > 200) {
        if (!_0x1a2b) {
          _0x1a2b = true;
          // Developer tools detected - silent monitoring
        }
      } else {
        _0x1a2b = false;
      }
    };
    
    window.addEventListener(_0x4a7c[2], _0x3c4d);
    setInterval(_0x3c4d, 1000);
  })();

  // Integrity Monitoring
  (function() {
    const _0x9i0j = document[_0x4a7c[7]];
    setInterval(() => {
      if (document[_0x4a7c[7]] !== _0x9i0j) {
        console.warn('¬© 2025 Jennifer Ladesma - Unauthorized modification detected');
        document[_0x4a7c[7]] = _0x9i0j;
      }
    }, 30000);
  })();

  // Console Protection
  (function() {
    const _0x1k2l = () => {
      console.clear();
      console.log('%c¬© 2025 Jennifer Ladesma - All Rights Reserved', 'color: purple; font-size: 14px;');
      console.log('%c‚ö†Ô∏è This application is protected by copyright law', 'color: red; font-weight: bold; font-size: 12px;');
      console.log('%cUnauthorized access, modification, or distribution is prohibited', 'color: orange; font-size: 10px;');
    };
    
    _0x1k2l();
    setInterval(_0x1k2l, 15000);
  })();

  // Data Protection - Session Cleanup
  window.addEventListener('beforeunload', function() {
    try {
      sessionStorage.clear();
      localStorage.removeItem('nursingScheduleData');
      localStorage.removeItem('tempScheduleData');
    } catch(e) {}
  });

  // Right-Click Protection
  document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
    return false;
  });

  // Key Combination Protection
  document.addEventListener('keydown', function(e) {
    // Disable F12, Ctrl+Shift+I, Ctrl+Shift+C, Ctrl+U
    if (e.key === 'F12' || 
        (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'C')) ||
        (e.ctrlKey && e.key === 'u')) {
      e.preventDefault();
      return false;
    }
  });

  // Text Selection Protection (Optional - Commented to preserve usability)
  // document.addEventListener('selectstart', function(e) {
  //   e.preventDefault();
  //   return false;
  // });

  // Domain Verification (Framework - Currently allows all domains)
  (function() {
    // const allowedDomains = ['yourdomain.com', 'localhost'];
    // if (!allowedDomains.some(domain => window.location.hostname.includes(domain))) {
    //   document.body.innerHTML = '<h1>¬© 2025 Jennifer Ladesma - Unauthorized Domain</h1>';
    // }
  })();

  // Basic License System (Framework - Currently auto-activated)
  (function() {
    const _0x2m3n = {
      key: 'DEV-LICENSE-2025',
      status: 'active',
      expires: '2025-12-31'
    };
    
    if (_0x2m3n.status !== 'active') {
      document.body.innerHTML = '<h1>¬© 2025 Jennifer Ladesma - License Required</h1>';
    }
  })();

  </script>
</body>
</html>